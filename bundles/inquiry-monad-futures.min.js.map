{"version":3,"sources":["webpack://InquiryMonadFutures/webpack/universalModuleDefinition","webpack://InquiryMonadFutures/webpack/bootstrap","webpack://InquiryMonadFutures/./node_modules/inquiry-monad/built/symbols.js","webpack://InquiryMonadFutures/external \"Inquiry\"","webpack://InquiryMonadFutures/external \"Future\"","webpack://InquiryMonadFutures/./node_modules/simple-maybe/src/index.js","webpack://InquiryMonadFutures/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__1__","__WEBPACK_EXTERNAL_MODULE__2__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","$$inquirySymbol","Symbol","$$questionsetSymbol","$$questionSymbol","$$passSymbol","$$failSymbol","$$iouSymbol","$$receiptSymbol","Just","x","isJust","isNothing","inspect","_","map","f","Maybe","of","ap","y","chain","join","fork","g","sequence","Nothing","undefined","simple_maybe_1","fluture_1","Future","inquiry_monad_1","Pass","Fail","IOU","Questionset","Question","Receipt","symbols_js_1","noop","buildInqF","vals","reduce","acc","cur","answer","InquiryF","resolveQs","iou","q","extract","InquiryFSubject","subject","fail","pass","informant","questionset","receipt","inquire","fnName","extractName","fExtractFn","find","inquireResponse","inquireIOU","concat","response","resp","console","warn","warnNotPassFail","syncronousResult","inquireMap","inq","ii","inquireAll","questions","using","a","swap","unison","breakpoint","length","milestone","conclude","parallel","Infinity","error","cleared","isEmpty","faulted","suffice","scratch","fold","zip","promise","[object Object]","exportInquiryF","warnTypeErrorF"],"mappings":"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","file":"inquiry-monad-futures.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Inquiry\"), require(\"Future\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InquiryMonadFutures\", [\"Inquiry\", \"Future\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InquiryMonadFutures\"] = factory(require(\"Inquiry\"), require(\"Future\"));\n\telse\n\t\troot[\"InquiryMonadFutures\"] = factory(root[\"Inquiry\"], root[\"Future\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__1__, __WEBPACK_EXTERNAL_MODULE__2__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$$inquirySymbol = Symbol();\nexports.$$questionsetSymbol = Symbol();\nexports.$$questionSymbol = Symbol();\nexports.$$passSymbol = Symbol();\nexports.$$failSymbol = Symbol();\nexports.$$iouSymbol = Symbol();\nexports.$$receiptSymbol = Symbol();\n//# sourceMappingURL=symbols.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__1__;","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","const Just = x => ({\n    isJust: true,\n    isNothing: false,\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    sequence: of => x.map(Maybe.of)\n});\n\nconst Nothing = _ => ({\n    isJust: false,\n    isNothing: true,\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    sequence: of => of(Nothing())\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","import { Maybe } from 'simple-maybe';\nimport { Future } from 'fluture';\nimport { Pass, Fail, IOU, Questionset, Question, Receipt } from 'inquiry-monad';\n\nimport {\n    Monad,\n    InquiryMonad,\n    IOUMonad,\n    PassFailMonad,\n    PassMonad,\n    FailMonad,\n    InquiryValue,\n    ReceiptMonad,\n    ReceiptValue,\n    QuestionsetMonad,\n    QuestionMonad,\n    QuestionValue\n} from 'inquiry-monad/built/inquiry-monad.js';\n\nimport {\n    $$inquirySymbol,\n    $$questionsetSymbol,\n    $$questionSymbol,\n    $$passSymbol,\n    $$failSymbol,\n    $$iouSymbol,\n    $$receiptSymbol\n} from 'inquiry-monad/built/symbols.js';\n\nconst noop = (): void => {};\n\nconst buildInqF = <T>(x: T) => (vals: Array<any>) =>\n    vals.reduce((acc, cur) => cur[1].answer(acc, '(async fn)', InquiryF), x);\n\n// this is a bit complex, so here it goes:\n// Take all our IOUs (Questions), extract and resolve their Futures\n// then take those results apply to a tuple with the question name/description and result\nconst resolveQs = (x: InquiryValue) =>\n    x.iou.join().map(\n        (q: QuestionMonad): any =>\n            q\n                .extract()()\n                .chain((f: Future<any, any>) => Future.of([q.name(), f]))\n    );\n\nconst InquiryFSubject = (x: any | InquiryMonad): InquiryMonad =>\n    x[$$inquirySymbol]\n        ? x\n        : InquiryF({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _,\n              questionset: Questionset.of([['', noop]]),\n              receipt: Receipt([])\n          });\n\nconst warnTypeErrorF = <T>(x: T) => {\n    console.warn(\n        'InquiryF.of requires properties: subject, fail, pass, iou, informant, questionset, receipt. Converting to InquiryF.subject().'\n    );\n    return InquiryFSubject(x);\n};\n\nconst InquiryFOf = (x: InquiryValue) =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x &&\n    'questionset' in x &&\n    'receipt' in x\n        ? InquiryF(x)\n        : warnTypeErrorF(x);\n\nconst InquiryF = (x: InquiryValue): InquiryMonad => ({\n    // Inquire: core method\n\n    inquire: (f: Function | string | QuestionMonad) => {\n        const extractName = (f: string | QuestionMonad) =>\n            (f as QuestionMonad)[$$questionSymbol]\n                ? (f as QuestionMonad).name()\n                : f;\n        const fnName =\n            typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = (f as any)[$$questionSymbol]\n            ? (f as QuestionMonad).extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n        const warnNotPassFail = (resp: any): InquiryMonad => {\n            console.warn(\n                'inquire was passed a function that does not return Pass or Fail:',\n                fnName\n            );\n            console.warn('response was:', resp);\n            return InquiryF(x);\n        };\n\n        const inquireResponse =\n            typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n\n        const syncronousResult = (response: any): InquiryMonad =>\n            response[$$failSymbol] ||\n            response[$$passSymbol] ||\n            response[$$inquirySymbol]\n                ? response.answer(x, fnName, InquiryF)\n                : warnNotPassFail([inquireResponse, fnName]);\n\n        const inquireIOU =\n            inquireResponse instanceof Future\n                ? Question.of([fnName as string, () => inquireResponse])\n                : false;\n\n        return inquireIOU\n            ? InquiryF({\n                  subject: x.subject,\n                  fail: x.fail,\n                  pass: x.pass,\n                  iou: x.iou.concat(IOU([inquireIOU])),\n                  informant: x.informant,\n                  questionset: x.questionset,\n                  receipt: x.receipt\n              })\n            : syncronousResult(inquireResponse);\n    },\n\n    inquireMap: (\n        f: Function | string | QuestionMonad,\n        i: Array<any>\n    ): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const extractName = (f: string | QuestionMonad) =>\n                    (f as QuestionMonad)[$$questionSymbol]\n                        ? (f as QuestionMonad).name()\n                        : f;\n                const fnName =\n                    typeof f === 'function' ? f.name || 'anon' : extractName(f);\n                const fExtractFn = (f as any)[$$questionSymbol]\n                    ? (f as QuestionMonad).extract()\n                    : f;\n                const fIsFn = typeof fExtractFn === 'function';\n                const inquire = fIsFn\n                    ? fExtractFn\n                    : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n                const warnNotPassFail = (resp: any) => {\n                    console.warn(\n                        'inquire was passed a function that does not return Pass or Fail:',\n                        fnName\n                    );\n                    console.warn('response was:', resp);\n                    return inq;\n                };\n                const inquireResponse =\n                    typeof inquire === 'function'\n                        ? inquire(ii)(inq.join().subject.join())\n                        : {};\n\n                const syncronousResult = (response: any): InquiryMonad =>\n                    response[$$failSymbol] ||\n                    response[$$passSymbol] ||\n                    response[$$inquirySymbol]\n                        ? response.answer(inq.join(), fnName, InquiryF)\n                        : Pass(response).answer(x, fnName, InquiryF); // @todo this should be warNotPassFail\n\n                return inquireResponse instanceof Future\n                    ? InquiryF({\n                          subject: inq.join().subject,\n                          fail: inq.join().fail,\n                          pass: inq.join().pass,\n                          iou: inq.join().iou.concat(IOU([inquireResponse])),\n                          informant: inq.join().informant,\n                          questionset: inq.join().questionset,\n                          receipt: inq.join().receipt\n                      })\n                    : syncronousResult(inquireResponse);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            InquiryF({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant,\n                questionset: x.questionset,\n                receipt: x.receipt\n            })\n        ),\n\n    inquireAll: (): InquiryMonad =>\n        (x.questionset as QuestionsetMonad).chain(\n            (questions: Array<QuestionValue>): InquiryMonad =>\n                questions.reduce(\n                    (inq: InquiryMonad, q: QuestionValue): InquiryMonad =>\n                        inq.inquire(Question.of(q)),\n                    InquiryF(x)\n                )\n        ),\n\n    using: (a: QuestionsetMonad): InquiryMonad =>\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: x.informant,\n            questionset: a,\n            receipt: x.receipt\n        }),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        InquiryF({\n            // @todo accept array of functions instead, or have a plural version\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    inspect: (): string =>\n        `InquiryF(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: (): InquiryMonad =>\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort), iou untouched\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f: Function): InquiryMonad => InquiryFSubject(f(x)), // cast required for now\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): InquiryValue => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) => (x.fail.join().length ? f(x) : InquiryF(x)),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) => (x.pass.join().length ? f(x) : InquiryF(x)),\n\n    // internal method: execute informant, return new InquiryF() based on updated results\n    answer: (i: InquiryValue, n: string, _: Function): InquiryMonad => {\n        i.informant([n, InquiryF(x)]);\n        return InquiryF({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt\n        });\n    },\n\n    // Unwrapping methods: all return Futures, all complete outstanding IOUs\n\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: (f: Function, g: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map((i: any) => (i[$$inquirySymbol] ? i.join() : i))\n            .fork(console.error, (y: InquiryValue) => ({\n                subject: y.subject,\n                iou: y.iou,\n                fail: f(y.fail),\n                pass: g(y.pass),\n                informant: y.informant,\n                questionset: y.questionset,\n                receipt: y.receipt\n            })),\n\n    // If no fails, handoff aggregated passes to supplied function; if fails, return existing InquiryF\n    cleared: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: InquiryValue) =>\n                    y.fail.isEmpty() ? f(y.pass) : InquiryF(y)\n            ),\n\n    // If fails, handoff aggregated fails to supplied function; if no fails, return existing InquiryF\n    faulted: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: InquiryValue) =>\n                    y.fail.isEmpty() ? InquiryF(y) : f(y.fail)\n            ),\n\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return existing InquiryF\n    suffice: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: InquiryValue) =>\n                    y.pass.isEmpty() ? InquiryF(y) : f(y.pass)\n            ),\n\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return existing InquiryF\n    scratch: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: InquiryValue) =>\n                    y.pass.isEmpty() ? f(y.fail) : InquiryF(y)\n            ),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: (f: Function, g: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: InquiryValue) =>\n                    y.fail.join().length ? f(y.fail) : g(y.pass)\n            ),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fold: (f: Function, g: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: InquiryValue) =>\n                    y.pass.join().length ? f(y.pass) : g(y.fail)\n            ),\n\n    // return a Future containing a merged fail/pass resultset array\n    zip: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    $$inquirySymbol in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(console.error, (y: InquiryValue) =>\n                f(y.fail.join().concat(y.pass.join()))\n            ),\n\n    // resolves all IOUs, returns a Promise\n    // @ts-ignore @todo add .promise as optional part of an Inquiry\n    promise: (): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, resolveQs(x))\n            .map(buildInqF(x))\n            .promise(),\n\n    // @ts-ignore\n    [$$inquirySymbol]: true\n});\n\nconst exportInquiryF = {\n    subject: InquiryFSubject,\n    of: InquiryFOf\n};\n\nexport {\n    exportInquiryF as InquiryF,\n    Pass,\n    Fail,\n    IOU,\n    Future,\n    $$inquirySymbol,\n    Questionset,\n    Question,\n    Receipt\n};\n"],"sourceRoot":""}