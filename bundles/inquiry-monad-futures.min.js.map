{"version":3,"sources":["webpack://InquiryMonadFutures/webpack/universalModuleDefinition","webpack://InquiryMonadFutures/webpack/bootstrap","webpack://InquiryMonadFutures/./node_modules/inquiry-monad/built/symbols.js","webpack://InquiryMonadFutures/./node_modules/inquiry-monad/node_modules/simple-maybe/src/index.js","webpack://InquiryMonadFutures/./node_modules/inquiry-monad/built/index.js","webpack://InquiryMonadFutures/external \"Future\"","webpack://InquiryMonadFutures/./node_modules/simple-maybe/src/index.js","webpack://InquiryMonadFutures/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__3__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","$$inquirySymbol","Symbol","$$questionsetSymbol","$$questionSymbol","$$passSymbol","$$failSymbol","$$iouSymbol","$$receiptSymbol","Just","x","isJust","isNothing","inspect","_","map","f","Maybe","of","ap","y","chain","join","fork","g","sequence","Nothing","undefined","__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","simple_maybe_1","symbols_1","noop","$$notFoundSymbol","PromiseEvery","promises","results","count","forEach","promise","idx","catch","err","valueOrError","length","IOU","concat","head","Array","isArray","tail","isEmpty","Boolean","[object Object]","Pass","fold","answer","Ix","Inquiry","informant","subject","fail","iou","pass","questionset","receipt","Receipt","Fail","Question","extract","QuestionOf","console","error","questionTypeError","exportQuestion","Questionset","find","a","RegExp","test","b","warn","exportQuestionset","questionsetTypeError","InquirySubject","inquire","fnName","extractName","fExtractFn","inquireResponse","resp","warnNotPassFail","inquireMap","reduce","inq","ii","inquireAll","questions","q","using","swap","unison","breakpoint","milestone","conclude","cleared","faulted","suffice","scratch","zip","exportInquiry","warnTypeError","InquiryPSubject","InquiryP","InquiryPOf","warnTypeErrorP","buildInq","vals","acc","cur","resolveQs","inquireIOU","response","syncronousResult","await","t","Infinity","timeLimit","setTimeout","awaitPromises","race","exportInquiryP","$$JustSymbol","$$NothingSymbol","forkL","forkR","fluture_1","Future","inquiry_monad_1","buildInqF","InquiryF","push","InquiryFSubject","exportInquiryF","warnTypeErrorF"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,EAAAG,QAAA,WACA,mBAAAC,eAAAC,IACAD,OAAA,iCAAAJ,GACA,iBAAAC,QACAA,QAAA,oBAAAD,EAAAG,QAAA,WAEAJ,EAAA,oBAAAC,EAAAD,EAAA,QARA,CASCO,OAAA,SAAAC,GACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAT,QAGA,IAAAC,EAAAM,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAX,YAUA,OANAY,EAAAH,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAU,GAAA,EAGAV,EAAAD,QA2CA,OAtCAQ,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAhB,EAAAiB,EAAAC,GACAV,EAAAW,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAzB,GACAoB,OAAAC,eAAArB,EAAA,cAAiD0B,OAAA,KAIjDlB,EAAAmB,EAAA,SAAA1B,GACA,IAAAiB,EAAAjB,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAO,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDtB,EAAAyB,EAAA,GAIAzB,IAAA0B,EAAA,kCClEAd,OAAAC,eAAArB,EAAA,cAA8C0B,OAAA,IAC9C1B,EAAAmC,gBAAAC,SACApC,EAAAqC,oBAAAD,SACApC,EAAAsC,iBAAAF,SACApC,EAAAuC,aAAAH,SACApC,EAAAwC,aAAAJ,SACApC,EAAAyC,YAAAL,SACApC,EAAA0C,gBAAAN,wBCRA,MAAAO,EAAAC,KACAC,QAAA,EACAC,WAAA,EACAC,QAAAC,WAA0BJ,KAC1BK,IAAAC,GAAAC,EAAAC,GAAAF,EAAAN,IACAS,GAAAC,KAAAL,IAAAL,GACAW,MAAAL,KAAAN,GACAY,KAAAR,GAAAJ,EACAa,KAAA,CAAAT,EAAAU,MAAAd,GACAe,SAAAP,GAAAR,EAAAK,IAAAE,EAAAC,MAGAQ,EAAAZ,KACAH,QAAA,EACAC,WAAA,EACAC,QAAAC,GAAA,UACAC,IAAAD,GAAAY,IACAP,GAAAL,GAAAY,IACAL,MAAAP,GAAAY,IACAJ,KAAAR,GAAAY,IACAH,KAAA,CAAAP,EAAAF,IAAAE,IACAS,SAAAP,KAAAQ,OAGAT,GACAC,GAAAR,GAAA,OAAAA,QAAAiB,IAAAjB,EAAAgB,IAAAjB,EAAAC,IAGA3C,EAAAD,SAAkBmD,QAAAS,UAAAjB,sCC3BlB,IAAAmB,EAAAC,WAAAD,WAAA,SAAAE,EAAAC,EAAAC,EAAAC,GACA,WAAAD,MAAAE,UAAA,SAAAC,EAAAC,GACA,SAAAC,EAAA7C,GAAmC,IAAM8C,EAAAL,EAAAM,KAAA/C,IAA+B,MAAAgD,GAAYJ,EAAAI,IACpF,SAAAC,EAAAjD,GAAkC,IAAM8C,EAAAL,EAAA,MAAAzC,IAAmC,MAAAgD,GAAYJ,EAAAI,IACvF,SAAAF,EAAAI,GAA+BA,EAAAC,KAAAR,EAAAO,EAAAlD,OAAA,IAAAwC,EAAA,SAAAG,GAAiEA,EAAAO,EAAAlD,SAAyBoD,KAAAP,EAAAI,GACzHH,GAAAL,IAAAY,MAAAf,EAAAC,QAAAQ,WAGArD,OAAAC,eAAArB,EAAA,cAA8C0B,OAAA,IAC9C,MAAAsD,EAAAxE,EAAA,GACAyE,EAAAzE,EAAA,GACAR,EAAAmC,gBAAA8C,EAAA9C,gBACAnC,EAAAsC,iBAAA2C,EAAA3C,iBACAtC,EAAAuC,aAAA0C,EAAA1C,aACAvC,EAAAwC,aAAAyC,EAAAzC,aACA,MAAA0C,EAAA,OACAC,EAAA/C,OAAA,aAEAgD,EAAAC,GAAA,IAAAjB,QAAAC,IACA,MAAAiB,KACA,IAAAC,EAAA,EACAF,EAAAG,QAAA,CAAAC,EAAAC,KACAD,EACAE,MAAAC,MACAd,KAAAe,IACAP,EAAAI,GAAAG,GACAN,GAAA,KACAF,EAAAS,QAAAzB,EAAAiB,SAIAS,EAAAnD,KACAK,IAAAC,GAAA6C,EAAA7C,EAAAN,IACAW,MAAAL,KAAAN,GACAS,GAAAC,KAAAL,IAAAL,GACAG,QAAA,WAA0BH,KAC1BY,KAAA,IAAAZ,EACAoD,OAAA7E,KAAAoC,MAAA9B,GAAAsE,EAAAnD,EAAAoD,OAAAvE,KACAwE,KAAA,IAAAC,MAAAC,QAAAvD,MAAAkD,OAAAlD,EAAA,MACAwD,KAAA,IAAAF,MAAAC,QAAAvD,MAAAkD,OAAAlD,IAAAkD,OAAA,MACAO,QAAA,IAAAC,SAAAJ,MAAAC,QAAAvD,IAAA,IAAAA,EAAAkD,QACAS,CAAAtB,EAAA9C,kBAAA,EACAoE,CAAAtB,EAAA1C,eAAA,EACAgE,CAAAtB,EAAAzC,eAAA,EACA+D,CAAAtB,EAAAxC,cAAA,IAEAzC,EAAA+F,MACA,MAAAS,EAAA5D,KACAK,IAAAC,GAAAsD,EAAAtD,EAAAN,IACAW,MAAAL,KAAAN,GACA6D,KAAA,CAAAvD,EAAAF,IAAAE,EAAAN,GACAa,KAAA,CAAAT,EAAAE,MAAAN,GACAqD,KAAA,IAAAC,MAAAC,QAAAvD,MAAAkD,OAAAlD,EAAA,MACAwD,KAAA,IAAAF,MAAAC,QAAAvD,MAAAkD,OAAAlD,IAAAkD,OAAA,MACAtC,KAAA,IAAAZ,EACAG,QAAA,YAA2BH,KAC3BoD,OAAA7E,KAAAsF,KAAAhF,GAAA+E,EAAA5D,EAAAoD,OAAAvE,IAAAyD,GACA7B,GAAAC,KAAA2B,EAAA1C,cAAAe,EAAA0C,OAAAQ,EAAA5D,IAAA4D,EAAA5D,GACA8D,OAAA,CAAAhG,EAAAiB,EAAA,cAAAgF,EAAAC,KACAlG,EAAAmG,WAAAlF,EAAA6E,EAAA5D,KACA+D,GACAG,QAAApG,EAAAoG,QACAC,KAAArG,EAAAqG,KACAC,IAAAtG,EAAAsG,IACAC,KAAAvG,EAAAuG,KAAAjB,OAAAQ,EAAA5D,IACAiE,UAAAnG,EAAAmG,UACAK,YAAAxG,EAAAwG,YACAC,QAAAzG,EAAAyG,QAAAnB,OAAAoB,IAAAzF,EAAA6E,EAAA5D,UAGAyD,QAAA,IAAAC,SAAAJ,MAAAC,QAAAvD,IAAA,IAAAA,EAAAkD,QACAS,CAAAtB,EAAA1C,eAAA,EACAgE,CAAAtB,EAAAzC,eAAA,EACA+D,CAAAtB,EAAAxC,cAAA,EACA8D,CAAAtB,EAAA9C,kBAAA,IAEAnC,EAAAwG,OACA,MAAAa,EAAAzE,KACAK,IAAAC,GAAAmE,EAAAnE,EAAAN,IACAW,MAAAL,KAAAN,GACA6D,KAAA,CAAAzD,EAAAE,MAAAN,GACAa,KAAA,CAAAP,EAAAF,IAAAE,EAAAN,GACAqD,KAAA,IAAAC,MAAAC,QAAAvD,MAAAkD,OAAAlD,EAAA,MACAwD,KAAA,IAAAF,MAAAC,QAAAvD,MAAAkD,OAAAlD,IAAAkD,OAAA,MACAtC,KAAA,IAAAZ,EACAG,QAAA,YAA2BH,KAC3BoD,OAAA7E,KAAAsC,KAAAhC,GAAA4F,EAAAzE,EAAAoD,OAAAvE,IAAAyD,GACA7B,GAAAC,KAAA2B,EAAA1C,cAAA8E,EAAAzE,GAAAU,EAAA0C,OAAAqB,EAAAzE,IACA8D,OAAA,CAAAhG,EAAAiB,EAAA,cAAAgF,EAAAC,KACAlG,EAAAmG,WAAAlF,EAAA0F,EAAAzE,KACA+D,GACAG,QAAApG,EAAAoG,QACAC,KAAArG,EAAAqG,KAAAf,OAAAqB,EAAAzE,IACAqE,KAAAvG,EAAAuG,KACAD,IAAAtG,EAAAsG,IACAH,UAAAnG,EAAAmG,UACAK,YAAAxG,EAAAwG,YACAC,QAAAzG,EAAAyG,QAAAnB,OAAAoB,IAAAzF,EAAA0F,EAAAzE,UAGAyD,QAAA,IAAAC,SAAAJ,MAAAC,QAAAvD,IAAA,IAAAA,EAAAkD,QACAS,CAAAtB,EAAA1C,eAAA,EACAgE,CAAAtB,EAAAzC,eAAA,EACA+D,CAAAtB,EAAAxC,cAAA,EACA8D,CAAAtB,EAAA9C,kBAAA,IAEAnC,EAAAqH,OACA,MAAAD,EAAAxE,KACAK,IAAAC,GAAAkE,EAAAlE,EAAAN,IACAW,MAAAL,KAAAN,GACA6D,KAAA,CAAAzD,EAAAE,MAAAN,GACAa,KAAA,CAAAP,EAAAF,IAAAE,EAAAN,GACAqD,KAAA,IAAArD,EAAA,GACAwD,KAAA,IAAAxD,IAAAkD,OAAA,GACAtC,KAAA,IAAAZ,EACAG,QAAA,eAA8BH,KAC9ByD,QAAA,IAAAC,SAAAJ,MAAAC,QAAAvD,IAAA,IAAAA,EAAAkD,QACAE,OAAA7E,KAAAoC,MAAA9B,GAAA2F,EAAAxE,EAAAoD,OAAAvE,KACA4B,GAAAC,KAAAL,IAAAL,GACA2D,CAAAtB,EAAA9C,kBAAA,EACAoE,CAAAtB,EAAAvC,kBAAA,IAEA1C,EAAAoH,UACA,MACAE,EAAA1E,KACAK,IAAAC,GAAAoE,EAAApE,EAAAN,IACAW,MAAAL,KAAAN,GACAS,GAAAC,KAAAL,IAAAL,GACAG,QAAA,gBAA+BH,KAC/BY,KAAA,IAAAZ,EACA/B,KAAAH,GAAAkC,EAAA,GAAAlC,EAAA8C,OAAAsD,QAAAtD,QACA+D,QAAA,IAAA3E,EAAA,GACA3B,KAAA,IAAA2B,EAAA,GACA2D,CAAAtB,EAAA3C,mBAAA,IAEAkF,EAAA5E,GAAAsD,MAAAC,QAAAvD,GAAA0E,EAAA1E,GAZA,CAAAA,GAAA6E,QAAAC,MAAA,gGAAA9E,GAYA+E,CAAA/E,GACAgF,GACAxE,GAAAoE,GAEAxH,EAAAsH,SAAAM,EACA,MAAAC,EAAAjF,KACAK,IAAAC,GAAA2E,EAAA3E,EAAAN,IACAW,MAAAL,KAAAN,GACAS,GAAAC,KAAAL,IAAAL,GACAG,QAAA,mBAAkCH,KAClCY,KAAA,IAAAZ,EACAoD,OAAA7E,KAAAoC,MAAA9B,GAAAoG,EAAAjF,EAAAoD,OAAAvE,KACAqG,KAAAC,GAAA/C,EAAA7B,MAAAC,GAAAR,EAAAkF,KAAApH,GAAAsH,OAAAtH,EAAA,IAAAuH,KAAAF,KACA9E,IAAAiF,KAAA,IACAzE,KAAA,KACAgE,QAAAU,KAAA,2BAAAJ,GACA5C,GACKpE,MACLwF,CAAAtB,EAAA5C,sBAAA,IAIA+F,GACAhF,GAFAR,GAAAsD,MAAAC,QAAAvD,GAAAiF,EAAAjF,GADA,CAAAA,GAAA6E,QAAAC,MAAA,mGAAA9E,GACAyF,CAAAzF,IAIA5C,EAAA6H,YAAAO,EACA,MAAAE,EAAA1F,KAAAqC,EAAA9C,iBACAS,EACAgE,GACAE,QAAA9B,EAAA7B,MAAAC,GAAAR,GACAmE,KAAAM,MACAJ,KAAAT,MACAQ,IAAAjB,MACAc,UAAA7D,KACAkE,YAAAW,IAAA,GAAA3C,KACAiC,QAAAC,QAgBAR,EAAAhE,KAOA2F,QAAArF,IACA,MAGAsF,EAAA,mBAAAtF,IAAAjC,MAAA,OAHA,CAAAiC,KAAA+B,EAAA3C,kBACAY,EAAAjC,OACAiC,EACAuF,CAAAvF,GACAwF,EAAAxF,EAAA+B,EAAA3C,kBACAY,EAAAqE,UACArE,EAEAqF,EADA,mBAAAG,EAEAA,EACA9F,EAAAsE,YAAAY,KAAAY,GAMAC,EAAA,mBAAAJ,IAAA3F,EAAAkE,QAAAtD,WACA,OAAAmF,EAAA1D,EAAAzC,eACAmG,EAAA1D,EAAA1C,eACAoG,EAAA1D,EAAA9C,iBACAwG,EAAAjC,OAAA9D,EAAA4F,EAAA5B,GATA,CAAAgC,IACAnB,QAAAU,KAAA,mEAAAK,GACAf,QAAAU,KAAA,gBAAAS,GACAhC,EAAAhE,IAOAiG,EAAAF,EAAAH,KAEAM,WAAA,CAAA5F,EAAAxC,MAAAqI,OAAA,CAAAC,EAAAC,KACA,MAGAT,EAAA,mBAAAtF,IAAAjC,MAAA,OAHA,CAAAiC,KAAA+B,EAAA3C,kBACAY,EAAAjC,OACAiC,EACAuF,CAAAvF,GACAwF,EAAAxF,EAAA+B,EAAA3C,kBACAY,EAAAqE,UACArE,EAEAqF,EADA,mBAAAG,EAEAA,EACA9F,EAAAsE,YAAAY,KAAAY,GAMAC,EAAA,mBAAAJ,EACAA,EAAAU,EAAAV,CAAAS,EAAAxF,OAAAsD,QAAAtD,WAGA,OAAAmF,EAAA1D,EAAAzC,eACAmG,EAAA1D,EAAA1C,eACAoG,EAAA1D,EAAA9C,iBACAwG,EAAAjC,OAAAsC,EAAAxF,OAAAgF,EAAA5B,GAZA,CAAAgC,IACAnB,QAAAU,KAAA,mEAAAK,GACAf,QAAAU,KAAA,gBAAAS,GACAI,GAUAH,EAAAF,EAAAH,KAGA5B,GACAE,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAJ,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,WAGA+B,WAAA,IAAAtG,EAAAsE,YAAA3D,MAAA4F,KAAAJ,OAAA,CAAAC,EAAAI,IAAAJ,EAAAT,QAAAf,EAAA4B,IAAAxC,EAAAhE,KACAyG,MAAAtB,GAAAnB,GACAE,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAJ,UAAAjE,EAAAiE,UACAK,YAAAa,EACAZ,QAAAvE,EAAAuE,UAGAN,UAAA3D,GAAA0D,GACAE,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAJ,UAAA3D,EACAgE,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAEApE,QAAA,eAA8BH,EAAAmE,KAAAhE,aAAoBH,EAAAqE,KAAAlE,aAAoBH,EAAAoE,IAAAjE,YAEtEuG,KAAA,IAAA1C,GACAE,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAM,EAAAzE,EAAAqE,KAAAzD,QACAyD,KAAAT,EAAA5D,EAAAmE,KAAAvD,QACAqD,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAGAoC,OAAArG,GACA0D,GACAE,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAM,EAAAnE,EAAAN,EAAAmE,KAAAvD,SACAyD,KAAAT,EAAAtD,EAAAN,EAAAqE,KAAAzD,SACAqD,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAGAlE,IAAAC,GAAAoF,EAAApF,EAAAN,IACAS,GAAAC,KAAAL,IAAAL,GACAW,MAAAL,KAAAN,GACAY,KAAA,IAAAZ,EAEA4G,WAAAtG,GAAAN,EAAAmE,KAAAvD,OAAAsC,OAAAc,EAAA1D,EAAAN,IAAAgE,EAAAhE,GAEA6G,UAAAvG,GAAAN,EAAAqE,KAAAzD,OAAAsC,OAAAc,EAAA1D,EAAAN,IAAAgE,EAAAhE,GAEA8D,OAAA,CAAAhG,EAAAiB,EAAAqB,KACAtC,EAAAmG,WAAAlF,EAAAiF,EAAAhE,KACAgE,GACAE,QAAApG,EAAAoG,QACAE,IAAAtG,EAAAsG,IACAD,KAAArG,EAAAqG,KAAAf,OAAApD,EAAAmE,MACAE,KAAAvG,EAAAuG,KAAAjB,OAAApD,EAAAqE,MACAJ,UAAAnG,EAAAmG,UACAK,YAAAxG,EAAAwG,YACAC,QAAAzG,EAAAyG,WAKAuC,SAAA,CAAAxG,EAAAQ,MACAoD,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAA7D,EAAAN,EAAAmE,MACAE,KAAAvD,EAAAd,EAAAqE,MACAJ,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAGAwC,QAAAzG,GAAAN,EAAAmE,KAAAV,UAAAnD,EAAAN,EAAAqE,WAAA/B,EAEA0E,QAAA1G,GAAAN,EAAAmE,KAAAV,eAAAnB,EAAAhC,EAAAN,EAAAmE,MAEA8C,QAAA3G,GAAAN,EAAAqE,KAAAZ,eAAAnB,EAAAhC,EAAAN,EAAAqE,MAEA6C,QAAA5G,GAAAN,EAAAqE,KAAAZ,UAAAnD,EAAAN,EAAAmE,WAAA7B,EAEAzB,KAAA,CAAAP,EAAAQ,IAAAd,EAAAmE,KAAAvD,OAAAsC,OAAA5C,EAAAN,EAAAmE,MAAArD,EAAAd,EAAAqE,MAEAR,KAAA,CAAAvD,EAAAQ,IAAAd,EAAAqE,KAAAzD,OAAAsC,OAAA5C,EAAAN,EAAAqE,MAAAvD,EAAAd,EAAAmE,MAEAgD,IAAA7G,KAAAN,EAAAmE,KAAAvD,OAAAwC,OAAApD,EAAAqE,KAAAzD,SACA+C,CAAAtB,EAAA9C,kBAAA,IAEA6H,GACAlD,QAAAwB,EACAlF,GA3KAR,GAAA,YAAAA,GACA,SAAAA,GACA,SAAAA,GACA,QAAAA,GACA,cAAAA,GACA,gBAAAA,GACA,YAAAA,EACAgE,EAAAhE,GAZA,CAAAA,IACA6E,QAAAU,KAAA,+HACAG,EAAA1F,IAWAqH,CAAArH,IAqKA5C,EAAA4G,QAAAoD,EACA,MAAAE,EAAAtH,KAAAqC,EAAA9C,iBACAS,EACAuH,GACArD,QAAA9B,EAAA7B,MAAAC,GAAAR,GACAmE,KAAAM,MACAJ,KAAAT,MACAQ,IAAAjB,MACAc,UAAA7D,KACAkE,YAAAW,IAAA,GAAA3C,KACAiC,QAAAC,QAMAgD,EAAAxH,GAAA,YAAAA,GACA,SAAAA,GACA,SAAAA,GACA,QAAAA,GACA,cAAAA,GACA,gBAAAA,GACA,YAAAA,EACAuH,EAAAvH,GAXA,CAAAA,IACA6E,QAAAU,KAAA,iIACA+B,EAAAtH,IAUAyH,CAAAzH,GACA0H,EAAA1H,GAAA2H,KACAA,EAAAxB,OAAA,CAAAyB,EAAAC,QAAA,GAAA/D,OAAA8D,EAAAC,EAAA,GAAAN,GAAA3G,OAAAgH,EAAA5H,GACAA,EAIA8H,EAAA9H,KAAAoE,IAAAxD,OAAAsC,OACAlD,EAAAoE,IAAAxD,OAAAP,IAAAmG,KACA7B,SADA6B,GAEAzD,MAAAC,MACAd,KAAAF,GAAAR,QAAAC,SAAA+E,EAAAnI,OAAA2D,OACAR,QAAAC,WACA8F,EAAAvH,KACA2F,QAAArF,IACA,MAGAsF,EAAA,mBAAAtF,IAAAjC,MAAA,OAHA,CAAAiC,KAAA+B,EAAA3C,kBACAY,EAAAjC,OACAiC,EACAuF,CAAAvF,GACAwF,EAAAxF,EAAA+B,EAAA3C,kBACAY,EAAAqE,UACArE,EAEAqF,EADA,mBAAAG,EAEAA,EACA9F,EAAAsE,YAAAY,KAAAY,GAMAC,EAAA,mBAAAJ,IAAA3F,EAAAkE,QAAAtD,WAMAmH,IAAAhC,EAAA7D,MACA0C,GAAAgB,EAAA,IAAAG,IAEA,OAAAgC,EACAR,GACArD,QAAAlE,EAAAkE,QACAC,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAD,IAAApE,EAAAoE,IAAAhB,OAAAD,GAAA4E,KACA9D,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAhBA,CAAAyD,KAAA3F,EAAAzC,eACAoI,EAAA3F,EAAA1C,eACAqI,EAAA3F,EAAA9C,iBACAyI,EAAAlE,OAAA9D,EAAA4F,EAAA2B,GATA,CAAAvB,IACAnB,QAAAU,KAAA,mEAAAK,GACAf,QAAAU,KAAA,gBAAAS,GACAuB,EAAAvH,IAOAiG,EAAAF,EAAAH,IAcAqC,CAAAlC,IAEAG,WAAA,CAAA5F,EAAAxC,MAAAqI,OAAA,CAAAC,EAAAC,KACA,MAGAT,EAAA,mBAAAtF,IAAAjC,MAAA,OAHA,CAAAiC,KAAA+B,EAAA3C,kBACAY,EAAAjC,OACAiC,EACAuF,CAAAvF,GACAwF,EAAAxF,EAAA+B,EAAA3C,kBACAY,EAAAqE,UACArE,EAEAqF,EADA,mBAAAG,EAEAA,EACA9F,EAAAsE,YAAAY,KAAAY,GAMAC,EAAA,mBAAAJ,EACAA,EAAAU,EAAAV,CAAAS,EAAAxF,OAAAsD,QAAAtD,WAOA,OAAAmF,EAAA7D,KACAqF,GACArD,QAAAkC,EAAAxF,OAAAsD,QACAC,KAAAiC,EAAAxF,OAAAuD,KACAE,KAAA+B,EAAAxF,OAAAyD,KACAD,IAAAgC,EAAAxF,OAAAwD,IAAAhB,OAAAD,GAAA4C,KACA9B,UAAAmC,EAAAxF,OAAAqD,UACAK,YAAA8B,EAAAxF,OAAA0D,YACAC,QAAA6B,EAAAxF,OAAA2D,UAbA,CAAAyD,KAAA3F,EAAAzC,eACAoI,EAAA3F,EAAA1C,eACAqI,EAAA3F,EAAA9C,iBACAyI,EAAAlE,OAAAsC,EAAAxF,OAAAgF,EAAA2B,GAXA,CAAAvB,IACAnB,QAAAU,KAAA,mEAAAK,GACAf,QAAAU,KAAA,gBAAAS,GACAI,GASAH,CAAA+B,GAWAC,CAAAlC,IAGAwB,GACArD,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAJ,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,WAEA+B,WAAA,IAAAtG,EAAAsE,YAAA3D,MAAA4F,KAAAJ,OAAA,CAAAC,EAAAI,IAAAJ,EAAAT,QAAAf,EAAA4B,IAAAe,EAAAvH,KACAyG,MAAAtB,GAAAoC,GACArD,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAJ,UAAAjE,EAAAiE,UACAK,YAAAa,EACAZ,QAAAvE,EAAAuE,UAGAN,UAAA3D,GAAAiH,GACArD,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAnE,EAAAmE,KACAE,KAAArE,EAAAqE,KACAJ,UAAA3D,EACAgE,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAEApE,QAAA,gBAA+BH,EAAAmE,KAAAhE,aAAoBH,EAAAqE,KAAAlE,aAAoBH,EAAAoE,IAAAjE,YAEvEuG,KAAA,IAAAa,GACArD,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAM,EAAAzE,EAAAqE,KAAAzD,QACAyD,KAAAT,EAAA5D,EAAAmE,KAAAvD,QACAqD,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAGAoC,OAAArG,GACAiH,GACArD,QAAAlE,EAAAkE,QACAE,IAAApE,EAAAoE,IACAD,KAAAM,EAAAnE,EAAAN,EAAAmE,KAAAvD,SACAyD,KAAAT,EAAAtD,EAAAN,EAAAqE,KAAAzD,SACAqD,UAAAjE,EAAAiE,UACAK,YAAAtE,EAAAsE,YACAC,QAAAvE,EAAAuE,UAGAlE,IAAAC,GAAAgH,EAAAhH,EAAAN,IACAS,GAAAC,KAAAL,IAAAL,GACAW,MAAAL,KAAAN,GACAY,KAAA,IAAAZ,EAEA4G,WAAAtG,GAAAN,EAAAmE,KAAAvD,OAAAsC,OAAAqE,EAAAjH,EAAAN,IAAAuH,EAAAvH,GAEA6G,UAAAvG,GAAAN,EAAAqE,KAAAzD,OAAAsC,OAAAqE,EAAAjH,EAAAN,IAAAuH,EAAAvH,GAEA8D,OAAA,CAAAhG,EAAAiB,EAAAqB,KACAtC,EAAAmG,WAAAlF,EAAAwI,EAAAvH,KACAuH,GACArD,QAAApG,EAAAoG,QACAE,IAAAtG,EAAAsG,IACAD,KAAArG,EAAAqG,KAAAf,OAAApD,EAAAmE,MACAE,KAAAvG,EAAAuG,KAAAjB,OAAApD,EAAAqE,MACAJ,UAAAnG,EAAAmG,UACAK,YAAAxG,EAAAwG,YACAC,QAAAzG,EAAAyG,WAKAuC,SAAA,CAAAxG,EAAAQ,IAAAI,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KACAwD,QAAAxD,EAAAwD,QACAE,IAAA1D,EAAA0D,IACAD,KAAA7D,EAAAI,EAAAyD,MACAE,KAAAvD,EAAAJ,EAAA2D,MACAJ,UAAAvD,EAAAuD,UACAK,YAAA5D,EAAA4D,YACAC,QAAA7D,EAAA6D,aAIAwC,QAAAzG,GAAAY,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KAAAyD,KAAAV,UAAAnD,EAAAI,EAAA2D,WAAA/B,GACAS,MAAAC,GAAA6B,QAAAC,MAAA,MAAA9B,MAGAgE,QAAA1G,GAAAY,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KAAAyD,KAAAV,eAAAnB,EAAAhC,EAAAI,EAAAyD,SAGA8C,QAAA3G,GAAAY,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KAAA2D,KAAAZ,eAAAnB,EAAAhC,EAAAI,EAAA2D,OACAtB,MAAAC,GAAA6B,QAAAC,MAAA,MAAA9B,MAGAkE,QAAA5G,GAAAY,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KAAA2D,KAAAZ,UAAAnD,EAAAI,EAAAyD,WAAA7B,KAGAzB,KAAA,CAAAP,EAAAQ,IAAAI,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KAAAyD,KAAAvD,OAAAsC,OAAA5C,EAAAI,EAAAyD,MAAArD,EAAAJ,EAAA2D,SAGAR,KAAA,CAAAvD,EAAAQ,IAAAI,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,KAAA2D,KAAAzD,OAAAsC,OAAA5C,EAAAI,EAAA2D,MAAAvD,EAAAJ,EAAAyD,SAGAgD,IAAA7G,GAAAY,EAAAC,UAAA,qBACA,OAAAqB,EAAAsF,EAAA9H,IACAkC,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,GAAAJ,EAAAI,EAAAyD,KAAAvD,OAAAwC,OAAA1C,EAAA2D,KAAAzD,YAGAsH,MAAA,CAAAC,EAAAC,MAAAlH,EAAAC,UAAA,qBAEA,MAAAkH,EAAA,IAAA7G,QAAA,CAAAC,EAAAC,IAAA4G,WAAA7G,EAAA0G,GACA,UACA1D,EAAA,gCAEA8D,EAAA/F,EAAAsF,EAAA9H,IACA,OAAAwB,QAAAgH,MAAAH,EAAAE,IAEArG,KAAAwF,EAAA1H,IACAkC,KAAApE,KAAAuE,EAAA9C,iBAAAzB,EAAA8C,OAAA9C,GACAoE,KAAAxB,GAAA8G,EAAA9G,MAEAiD,CAAAtB,EAAA9C,kBAAA,IAEAkJ,GACAvE,QAAAoD,EACA9G,GAAAgH,GAEApK,EAAAmK,SAAAkB,iBCjnBApL,EAAAD,QAAAM,iBCAA,MAAAgL,EAAAlJ,SACAmJ,EAAAnJ,SAEAO,EAAAC,KACAG,QAAAC,WAA0BJ,KAC1BK,IAAAC,GAAAC,EAAAC,GAAAF,EAAAN,IACAS,GAAAC,KAAAL,IAAAL,GACAW,MAAAL,KAAAN,GACAY,KAAAR,GAAAJ,EACAa,KAAA,CAAAT,EAAAU,MAAAd,GACA4I,MAAAxI,GAAAY,IACA6H,MAAAvI,KAAAN,GACAe,SAAAP,GAAAR,EAAAK,IAAAE,EAAAC,IACAmD,CAAA+E,IAAA,EACA/E,CAAAgF,IAAA,IAGA3H,EAAAZ,KACAD,QAAAC,GAAA,UACAC,IAAAD,GAAAY,IACAP,GAAAL,GAAAY,IACAL,MAAAP,GAAAY,IACAJ,KAAAR,GAAAY,IACAH,KAAA,CAAAP,EAAAF,IAAAE,IACAsI,MAAAtI,OACAuI,MAAA,IAAA7H,IACAD,SAAAP,KAAAQ,KACA2C,CAAA+E,IAAA,EACA/E,CAAAgF,IAAA,IAGApI,GACAC,GAAAR,GAAA,OAAAA,QAAAiB,IAAAjB,KAAA2I,GAAA3H,IAAAjB,EAAAC,IAGA3C,EAAAD,SAAkBmD,QAAAS,UAAAjB,uFCnClB,MAAAqC,EAAAxE,EAAA,GACAkL,EAAAlL,EAAA,GA6cIR,EAAA2L,OA7cKD,EAAAC,OACT,MAAAC,EAAApL,EAAA,GAycIR,EAAAwG,KAzcKoF,EAAApF,KA0cLxG,EAAAqH,KA1cWuE,EAAAvE,KA2cXrH,EAAA+F,IA3ciB6F,EAAA7F,IA8cjB/F,EAAA6H,YA9csB+D,EAAA/D,YA+ctB7H,EAAAsH,SA/cmCsE,EAAAtE,SAgdnCtH,EAAAoH,QAhd6CwE,EAAAxE,QAiBjD,MAAAnC,EAAAzE,EAAA,GA4bIR,EAAAmC,gBA3bA8C,EAAA9C,gBASJ,MAAM+C,EAAO,OAEP2G,EAAajJ,GAAqB2H,GACpCA,EAAKxB,OACD,CAACyB,EAAKC,IAAQA,EAAI,GAAG/D,OAAO8D,EAAIhH,OAAQ,aAAcsI,GACtDA,EAASlJ,IAMX8H,EAAa9H,GACfA,EAAEoE,IAAIxD,OAAOsC,OACP4F,EAAAC,OAAO,CAACrH,EAAQD,KACZ,MAAMiB,KACN1C,EAAEoE,IAAIxD,OAAOP,IACRmG,IACGA,EAAE7B,SAAF6B,GAAc3F,KAAKa,EAASM,IACxBU,EAAQyG,MAAM3C,EAAEnI,OAAQ2D,IACxBU,EAAQQ,SAAWlD,EAAEoE,IAAIxD,OAAOsC,QAC5BzB,EAAQiB,SAK5BoG,EAAAC,OAAOvI,OAEX4I,EAAmBpJ,GACrBA,EAAEqC,EAAA9C,iBACIS,EACAkJ,GACIhF,QAAS9B,EAAA7B,MAAMC,GAAGR,GAClBmE,KAAM6E,EAAAvE,SACNJ,KAAM2E,EAAApF,SACNQ,IAAK4E,EAAA7F,QACLc,UAAe7D,GAASA,EACxBkE,YAAa0E,EAAA/D,YAAYzE,KAAK,GAAI8B,KAClCiC,QAASyE,EAAAxE,cAqBjB0E,EAAYlJ,KAGd2F,QAAUrF,IACN,MAIMsF,EACW,mBAANtF,EAAmBA,EAAEjC,MAAQ,OALpB,CAACiC,GAChBA,EAAoB+B,EAAA3C,kBACdY,EAAoBjC,OACrBiC,EAEuCuF,CAAYvF,GACvDwF,EAAcxF,EAAU+B,EAAA3C,kBACvBY,EAAoBqE,UACrBrE,EAEAqF,EAD8B,mBAAfG,EAEfA,EACC9F,EAAEsE,YAAiCY,KAAKY,GAEzCC,EACiB,mBAAZJ,EAAyBA,EAAQ3F,EAAEkE,QAAQtD,WAiBhDmH,EACFhC,aAA2B+C,EAAAC,QACrBC,EAAAtE,SAASlE,IAAIoF,EAAkB,IAAMG,IAG/C,OAAOgC,EACDmB,GACIhF,QAASlE,EAAEkE,QACXC,KAAMnE,EAAEmE,KACRE,KAAMrE,EAAEqE,KACRD,IAAKpE,EAAEoE,IAAIhB,OAAO4F,EAAA7F,KAAK4E,KACvB9D,UAAWjE,EAAEiE,UACbK,YAAatE,EAAEsE,YACfC,QAASvE,EAAEuE,UApBI,CAACyD,GACtBA,EAAS3F,EAAAzC,eACToI,EAAS3F,EAAA1C,eACTqI,EAAS3F,EAAA9C,iBACHyI,EAASlE,OAAO9D,EAAG4F,EAAQsD,GAZb,CAAClD,IACrBnB,QAAQU,KACJ,mEACAK,GAEGsD,EAASlJ,IAQViG,GAiBJgC,CAAiBlC,IAG3BG,WAAY,CACR5F,EACAxC,IAEAA,EAAEqI,OACE,CAACC,EAAKC,KACF,MAIMT,EACW,mBAANtF,EAAmBA,EAAEjC,MAAQ,OALpB,CAACiC,GAChBA,EAAoB+B,EAAA3C,kBACdY,EAAoBjC,OACrBiC,EAEuCuF,CAAYvF,GACvDwF,EAAcxF,EAAU+B,EAAA3C,kBACvBY,EAAoBqE,UACrBrE,EAEAqF,EAD8B,mBAAfG,EAEfA,EACC9F,EAAEsE,YAAiCY,KAAKY,GASzCC,EACiB,mBAAZJ,EACDA,EAAQU,EAARV,CAAYS,EAAIxF,OAAOsD,QAAQtD,WAUzC,OAAOmF,aAA2B+C,EAAAC,OAC5BG,GACIhF,QAASkC,EAAIxF,OAAOsD,QACpBC,KAAMiC,EAAIxF,OAAOuD,KACjBE,KAAM+B,EAAIxF,OAAOyD,KACjBD,IAAKgC,EAAIxF,OAAOwD,IAAIhB,OAAO4F,EAAA7F,KAAK4C,KAChC9B,UAAWmC,EAAIxF,OAAOqD,UACtBK,YAAa8B,EAAIxF,OAAO0D,YACxBC,QAAS6B,EAAIxF,OAAO2D,UAfL,CAACyD,GACtBA,EAAS3F,EAAAzC,eACToI,EAAS3F,EAAA1C,eACTqI,EAAS3F,EAAA9C,iBACHyI,EAASlE,OAAOsC,EAAIxF,OAAQgF,EAAQsD,GACpCF,EAAApF,KAAKoE,GAAUlE,OAAO9D,EAAG4F,EAAQsD,GAYrCjB,CAAiBlC,IAI3BmD,GACIhF,QAASlE,EAAEkE,QACXE,IAAKpE,EAAEoE,IACPD,KAAMnE,EAAEmE,KACRE,KAAMrE,EAAEqE,KACRJ,UAAWjE,EAAEiE,UACbK,YAAatE,EAAEsE,YACfC,QAASvE,EAAEuE,WAIvB+B,WAAY,IACPtG,EAAEsE,YAAiC3D,MAC/B4F,GACGA,EAAUJ,OACN,CAACC,EAAmBI,IAChBJ,EAAIT,QAAQqD,EAAAtE,SAASlE,GAAGgG,IAC5B0C,EAASlJ,KAIzByG,MAAQtB,GACJ+D,GACIhF,QAASlE,EAAEkE,QACXE,IAAKpE,EAAEoE,IACPD,KAAMnE,EAAEmE,KACRE,KAAMrE,EAAEqE,KACRJ,UAAWjE,EAAEiE,UACbK,YAAaa,EACbZ,QAASvE,EAAEuE,UAInBN,UAAY3D,GACR4I,GAEIhF,QAASlE,EAAEkE,QACXE,IAAKpE,EAAEoE,IACPD,KAAMnE,EAAEmE,KACRE,KAAMrE,EAAEqE,KACRJ,UAAW3D,EACXgE,YAAatE,EAAEsE,YACfC,QAASvE,EAAEuE,UAGnBpE,QAAS,gBACOH,EAAEmE,KAAKhE,aAAaH,EAAEqE,KAAKlE,aAAaH,EAAEoE,IAAIjE,YAG9DuG,KAAM,IACFwC,GACIhF,QAASlE,EAAEkE,QACXE,IAAKpE,EAAEoE,IACPD,KAAM6E,EAAAvE,KAAKzE,EAAEqE,KAAKzD,QAClByD,KAAM2E,EAAApF,KAAK5D,EAAEmE,KAAKvD,QAClBqD,UAAWjE,EAAEiE,UACbK,YAAatE,EAAEsE,YACfC,QAASvE,EAAEuE,UAInBoC,OACIrG,GAEA4I,GACIhF,QAASlE,EAAEkE,QACXE,IAAKpE,EAAEoE,IACPD,KAAM6E,EAAAvE,KAAKnE,EAAEN,EAAEmE,KAAKvD,SACpByD,KAAM2E,EAAApF,KAAKtD,EAAEN,EAAEqE,KAAKzD,SACpBqD,UAAWjE,EAAEiE,UACbK,YAAatE,EAAEsE,YACfC,QAASvE,EAAEuE,UAInBlE,IAAMC,GAA8B8I,EAAgB9I,EAAEN,IACtDS,GAAKC,GAAaA,EAAEL,IAAIL,GACxBW,MAAQL,GAAgBA,EAAEN,GAC1BY,KAAM,IAAoBZ,EAG1B4G,WAAatG,GAAiBN,EAAEmE,KAAKvD,OAAOsC,OAAS5C,EAAEN,GAAKkJ,EAASlJ,GAGrE6G,UAAYvG,GAAiBN,EAAEqE,KAAKzD,OAAOsC,OAAS5C,EAAEN,GAAKkJ,EAASlJ,GAGpE8D,OAAQ,CAAChG,EAAiBiB,EAAWqB,KACjCtC,EAAEmG,WAAWlF,EAAGmK,EAASlJ,KAClBkJ,GACHhF,QAASpG,EAAEoG,QACXE,IAAKtG,EAAEsG,IACPD,KAAMrG,EAAEqG,KAAKf,OAAOpD,EAAEmE,MACtBE,KAAMvG,EAAEuG,KAAKjB,OAAOpD,EAAEqE,MACtBJ,UAAWnG,EAAEmG,UACbK,YAAaxG,EAAEwG,YACfC,QAASzG,EAAEyG,WASnBuC,SAAU,CAACxG,EAAaQ,IACpBgI,EAAAC,OAAO,CAACrH,EAAQD,IACZqG,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IAAKvC,GAAYA,EAAEuE,EAAA9C,iBAAmBzB,EAAE8C,OAAS9C,GACjD+C,KAAKa,EAAShB,GACXe,GACIyC,QAASxD,EAAEwD,QACXE,IAAK1D,EAAE0D,IACPD,KAAM7D,EAAEI,EAAEyD,MACVE,KAAMvD,EAAEJ,EAAE2D,MACVJ,UAAWvD,EAAEuD,UACbK,YAAa5D,EAAE4D,YACfC,QAAS7D,EAAE6D,YAM/BwC,QAAUzG,GACNwI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KACGgE,QAAQC,MACPpE,GACGA,EAAEyD,KAAKV,UAAYnD,EAAEI,EAAE2D,MAAQ6E,EAASxI,KAK5DsG,QAAU1G,GACNwI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KACGgE,QAAQC,MACPpE,GACGA,EAAEyD,KAAKV,UAAYyF,EAASxI,GAAKJ,EAAEI,EAAEyD,QAKzD8C,QAAU3G,GACNwI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KACGgE,QAAQC,MACPpE,GACGA,EAAE2D,KAAKZ,UAAYyF,EAASxI,GAAKJ,EAAEI,EAAE2D,QAKzD6C,QAAU5G,GACNwI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KACGgE,QAAQC,MACPpE,GACGA,EAAE2D,KAAKZ,UAAYnD,EAAEI,EAAEyD,MAAQ+E,EAASxI,KAK5DG,KAAM,CAACP,EAAaQ,IAChBgI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KACGgE,QAAQC,MACPpE,GACGA,EAAEyD,KAAKvD,OAAOsC,OAAS5C,EAAEI,EAAEyD,MAAQrD,EAAEJ,EAAE2D,QAK3DR,KAAM,CAACvD,EAAaQ,IAChBgI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KACGgE,QAAQC,MACPpE,GACGA,EAAE2D,KAAKzD,OAAOsC,OAAS5C,EAAEI,EAAE2D,MAAQvD,EAAEJ,EAAEyD,QAK3DgD,IAAM7G,GACFwI,EAAAC,OAAOvI,GACHsH,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACdK,IACOvC,GACAuE,EAAA9C,mBAAoBzB,EACbA,EAAmB8C,OACpB9C,GAEb+C,KAAKgE,QAAQC,MAAQpE,GAClBJ,EAAEI,EAAEyD,KAAKvD,OAAOwC,OAAO1C,EAAE2D,KAAKzD,WAM9CiC,QAAS,IACLiF,EAAU9H,GACLK,IAAI4I,EAAUjJ,IACd6C,UAGTc,CAACtB,EAAA9C,kBAAkB,IAGjB8J,GACFnF,QAASkF,EACT5I,GA1XgBR,GAChB,YAAaA,GACb,SAAUA,GACV,SAAUA,GACV,QAASA,GACT,cAAeA,GACf,gBAAiBA,GACjB,YAAaA,EACPkJ,EAASlJ,GAfI,CAAIA,IACvB6E,QAAQU,KACJ,iIAEG6D,EAAgBpJ,IAYjBsJ,CAAetJ,IAqXH5C,EAAA8L,SAAAG","file":"inquiry-monad-futures.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Future\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InquiryMonadFutures\", [\"Future\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InquiryMonadFutures\"] = factory(require(\"Future\"));\n\telse\n\t\troot[\"InquiryMonadFutures\"] = factory(root[\"Future\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__3__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.$$inquirySymbol = Symbol();\nexports.$$questionsetSymbol = Symbol();\nexports.$$questionSymbol = Symbol();\nexports.$$passSymbol = Symbol();\nexports.$$failSymbol = Symbol();\nexports.$$iouSymbol = Symbol();\nexports.$$receiptSymbol = Symbol();\n//# sourceMappingURL=symbols.js.map","const Just = x => ({\n    isJust: true,\n    isNothing: false,\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    sequence: of => x.map(Maybe.of)\n});\n\nconst Nothing = _ => ({\n    isJust: false,\n    isNothing: true,\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    sequence: of => of(Nothing())\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst simple_maybe_1 = require(\"simple-maybe\");\nconst symbols_1 = require(\"./symbols\");\nexports.$$inquirySymbol = symbols_1.$$inquirySymbol;\nexports.$$questionSymbol = symbols_1.$$questionSymbol;\nexports.$$passSymbol = symbols_1.$$passSymbol;\nexports.$$failSymbol = symbols_1.$$failSymbol;\nconst noop = () => { };\nconst $$notFoundSymbol = Symbol('Not found');\n// like Promise.all without the fast reject functionality\nconst PromiseEvery = (promises) => new Promise((resolve) => {\n    const results = [];\n    let count = 0;\n    promises.forEach((promise, idx) => {\n        promise\n            .catch(err => err) // pass errs down as (presumably) Fail\n            .then((valueOrError) => {\n            results[idx] = valueOrError;\n            count += 1;\n            count === promises.length && resolve(results);\n        });\n    });\n});\nconst IOU = (x) => ({\n    map: (f) => IOU(f(x)),\n    chain: (f) => f(x),\n    ap: (y) => y.map(x),\n    inspect: () => `IOU(${x})`,\n    join: () => x,\n    concat: (o) => o.chain((r) => IOU(x.concat(r))),\n    head: () => Array.isArray(x) && x.length ? x[0] : [],\n    tail: () => Array.isArray(x) && x.length ? x[x.length - 1] : [],\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    [symbols_1.$$inquirySymbol]: false,\n    [symbols_1.$$passSymbol]: false,\n    [symbols_1.$$failSymbol]: false,\n    [symbols_1.$$iouSymbol]: true\n});\nexports.IOU = IOU;\nconst Pass = (x) => ({\n    map: (f) => Pass(f(x)),\n    chain: (f) => f(x),\n    fold: (f, _) => f(x),\n    fork: (_, f) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => Array.isArray(x) && x.length ? x[x.length - 1] : [],\n    join: () => x,\n    inspect: () => `Pass(${x})`,\n    concat: (o) => o.fold((r) => Pass(x.concat(r)), noop),\n    ap: (y) => y[symbols_1.$$passSymbol] ? y.concat(Pass(x)) : Pass(x),\n    answer: (i, n = '(anonymous)', Ix = Inquiry) => {\n        i.informant([n, Pass(x)]);\n        return Ix({\n            subject: i.subject,\n            fail: i.fail,\n            iou: i.iou,\n            pass: i.pass.concat(Pass(x)),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt.concat(Receipt([[n, Pass(x)]]))\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    [symbols_1.$$passSymbol]: true,\n    [symbols_1.$$failSymbol]: false,\n    [symbols_1.$$iouSymbol]: false,\n    [symbols_1.$$inquirySymbol]: false\n});\nexports.Pass = Pass;\nconst Fail = (x) => ({\n    map: (f) => Fail(f(x)),\n    chain: (f) => f(x),\n    fold: (_, f) => f(x),\n    fork: (f, _) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => Array.isArray(x) && x.length ? x[x.length - 1] : [],\n    join: () => x,\n    inspect: () => `Fail(${x})`,\n    concat: (o) => o.fork((r) => Fail(x.concat(r)), noop),\n    ap: (y) => y[symbols_1.$$passSymbol] ? Fail(x) : y.concat(Fail(x)),\n    answer: (i, n = '(anonymous)', Ix = Inquiry) => {\n        i.informant([n, Fail(x)]);\n        return Ix({\n            subject: i.subject,\n            fail: i.fail.concat(Fail(x)),\n            pass: i.pass,\n            iou: i.iou,\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt.concat(Receipt([[n, Fail(x)]]))\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    [symbols_1.$$passSymbol]: false,\n    [symbols_1.$$failSymbol]: true,\n    [symbols_1.$$iouSymbol]: false,\n    [symbols_1.$$inquirySymbol]: false\n});\nexports.Fail = Fail;\nconst Receipt = (x) => ({\n    map: (f) => Receipt(f(x)),\n    chain: (f) => f(x),\n    fold: (_, f) => f(x),\n    fork: (f, _) => f(x),\n    head: () => x[0],\n    tail: () => x[x.length - 1],\n    join: () => x,\n    inspect: () => `Receipt(${x})`,\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    concat: (o) => o.chain((r) => Receipt(x.concat(r))),\n    ap: (y) => y.map(x),\n    [symbols_1.$$inquirySymbol]: false,\n    [symbols_1.$$receiptSymbol]: true\n});\nexports.Receipt = Receipt;\nconst questionTypeError = (x) => console.error('Question must be passed parameters that adhere to the documented type. Value that was passed:', x);\nconst Question = (x) => ({\n    map: (f) => Question(f(x)),\n    chain: (f) => f(x),\n    ap: (y) => y.map(x),\n    inspect: () => `Question(${x})`,\n    join: () => x,\n    call: (i) => x[1](i.join().subject.join()),\n    extract: () => x[1],\n    name: () => x[0],\n    [symbols_1.$$questionSymbol]: true\n});\nconst QuestionOf = (x) => Array.isArray(x) ? Question(x) : questionTypeError(x);\nconst exportQuestion = {\n    of: QuestionOf\n};\nexports.Question = exportQuestion;\nconst Questionset = (x) => ({\n    map: (f) => Questionset(f(x)),\n    chain: (f) => f(x),\n    ap: (y) => y.map(x),\n    inspect: () => `Questionset(${x})`,\n    join: () => x,\n    concat: (o) => o.chain((r) => Questionset(x.concat(r))),\n    find: (a) => simple_maybe_1.Maybe.of(x.find(i => RegExp(i[0]).test(a)))\n        .map((b) => b[1])\n        .fork(() => {\n        console.warn('Question was not found: ', a);\n        return $$notFoundSymbol;\n    }, (c) => c),\n    [symbols_1.$$questionsetSymbol]: true\n});\nconst questionsetTypeError = (x) => console.error('Questionset must be passed parameters that adhere to the documented type. Value that was passed:', x);\nconst QuestionsetOf = (x) => Array.isArray(x) ? Questionset(x) : questionsetTypeError(x);\nconst exportQuestionset = {\n    of: QuestionsetOf\n};\nexports.Questionset = exportQuestionset;\nconst InquirySubject = (x) => x[symbols_1.$$inquirySymbol]\n    ? x\n    : Inquiry({\n        subject: simple_maybe_1.Maybe.of(x),\n        fail: Fail([]),\n        pass: Pass([]),\n        iou: IOU([]),\n        informant: (_) => _,\n        questionset: Questionset([['', noop]]),\n        receipt: Receipt([])\n    });\nconst warnTypeError = (x) => {\n    console.warn('Inquiry.of requires properties: subject, fail, pass, iou, informant, questionset, receipt. Converting to Inquiry.subject().');\n    return InquirySubject(x);\n};\n// @todo validate constructor via Symbol\nconst InquiryOf = (x) => 'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x &&\n    'questionset' in x &&\n    'receipt' in x\n    ? Inquiry(x)\n    : warnTypeError(x);\nconst Inquiry = (x) => ({\n    // Inquire: core method\n    // You may pass a Function, a QuestionMonad (with a function), or a string which will look up\n    //  in the current Inquiry's questionset.\n    // @todo in 1.x, deprecate Function as an option\n    // @todo should we allow a Questionset to be passed here, and process all of them?\n    // @todo after simplifying, can BoolTable help here?\n    inquire: (f) => {\n        const extractName = (f) => f[symbols_1.$$questionSymbol]\n            ? f.name()\n            : f;\n        const fnName = typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = f[symbols_1.$$questionSymbol]\n            ? f.extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : x.questionset.find(fExtractFn);\n        const warnNotPassFail = (resp) => {\n            console.warn('inquire was passed a function that does not return Pass or Fail:', fnName);\n            console.warn('response was:', resp);\n            return Inquiry(x);\n        };\n        const inquireResponse = typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n        return inquireResponse[symbols_1.$$failSymbol] ||\n            inquireResponse[symbols_1.$$passSymbol] ||\n            inquireResponse[symbols_1.$$inquirySymbol]\n            ? inquireResponse.answer(x, fnName, Inquiry)\n            : warnNotPassFail([inquireResponse, fnName]);\n    },\n    inquireMap: (f, i) => i.reduce((inq, ii) => {\n        const extractName = (f) => f[symbols_1.$$questionSymbol]\n            ? f.name()\n            : f;\n        const fnName = typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = f[symbols_1.$$questionSymbol]\n            ? f.extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : x.questionset.find(fExtractFn);\n        const warnNotPassFail = (resp) => {\n            console.warn('inquire was passed a function that does not return Pass or Fail:', fnName);\n            console.warn('response was:', resp);\n            return inq;\n        };\n        const inquireResponse = typeof inquire === 'function'\n            ? inquire(ii)(inq.join().subject.join())\n            : {};\n        // each return aggregates new contained value through exit\n        return inquireResponse[symbols_1.$$failSymbol] ||\n            inquireResponse[symbols_1.$$passSymbol] ||\n            inquireResponse[symbols_1.$$inquirySymbol]\n            ? inquireResponse.answer(inq.join(), fnName, Inquiry)\n            : warnNotPassFail([inquireResponse, fnName]);\n    }, \n    // initial Inquiry will be what is in `x` now\n    Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    })),\n    // @todo handle if no Questionset / .using()\n    inquireAll: () => x.questionset.chain((questions) => questions.reduce((inq, q) => inq.inquire(QuestionOf(q)), Inquiry(x))),\n    using: (a) => Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: x.informant,\n        questionset: a,\n        receipt: x.receipt\n    }),\n    // Informant: for spying/logging/observable\n    informant: (f) => Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: f,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    inspect: () => `Inquiry(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n    // Flow control: swap pass/fail\n    swap: () => Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(x.pass.join()),\n        pass: Pass(x.fail.join()),\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    // Mapping across both branches\n    unison: (f) => // apply a single map to both fail & pass (e.g. sort)\n     Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(f(x.fail.join())),\n        pass: Pass(f(x.pass.join())),\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    // standard Monad methods\n    map: (f) => InquirySubject(f(x)),\n    ap: (y) => y.map(x),\n    chain: (f) => f(x),\n    join: () => x,\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f) => x.fail.join().length ? Inquiry(f(x)) : Inquiry(x),\n    // execute the provided function if there are passes, else continue\n    milestone: (f) => x.pass.join().length ? Inquiry(f(x)) : Inquiry(x),\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i, n, _) => {\n        i.informant([n, Inquiry(x)]);\n        return Inquiry({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt\n        });\n    },\n    // Unwrap methods\n    // unwraps, mapping for both branches, full value returned\n    conclude: (f, g) => ({\n        subject: x.subject,\n        iou: x.iou,\n        fail: f(x.fail),\n        pass: g(x.pass),\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    // If there are no fails, handoff aggregated passes to supplied function; if any fails, return noop\n    cleared: (f) => x.fail.isEmpty() ? f(x.pass) : noop(),\n    // If there are fails, handoff aggregated fails to supplied function; if no fails, return noop\n    faulted: (f) => x.fail.isEmpty() ? noop() : f(x.fail),\n    // If there are passes, handoff aggregated passes to supplied function; if no passes, return noop\n    suffice: (f) => x.pass.isEmpty() ? noop() : f(x.pass),\n    // If there are no passes, handoff aggregated fails to supplied function; if any passes, return noop\n    scratch: (f) => x.pass.isEmpty() ? f(x.fail) : noop(),\n    // unwrap left if any fails, right if not\n    fork: (f, g) => x.fail.join().length ? f(x.fail) : g(x.pass),\n    // unwrap left if any passes, right if not\n    fold: (f, g) => x.pass.join().length ? f(x.pass) : g(x.fail),\n    // return a merged pass/fail\n    zip: (f) => f(x.fail.join().concat(x.pass.join())),\n    [symbols_1.$$inquirySymbol]: true\n});\nconst exportInquiry = {\n    subject: InquirySubject,\n    of: InquiryOf\n};\nexports.Inquiry = exportInquiry;\nconst InquiryPSubject = (x) => x[symbols_1.$$inquirySymbol]\n    ? x\n    : InquiryP({\n        subject: simple_maybe_1.Maybe.of(x),\n        fail: Fail([]),\n        pass: Pass([]),\n        iou: IOU([]),\n        informant: (_) => _,\n        questionset: Questionset([['', noop]]),\n        receipt: Receipt([])\n    });\nconst warnTypeErrorP = (x) => {\n    console.warn('InquiryP.of requires properties: subject, fail, pass, iou, informant, questionset, receipt. Converting to InquiryP.subject().');\n    return InquiryPSubject(x);\n};\nconst InquiryPOf = (x) => 'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x &&\n    'questionset' in x &&\n    'receipt' in x\n    ? InquiryP(x)\n    : warnTypeErrorP(x);\nconst buildInq = (x) => (vals) => vals\n    ? vals.reduce((acc, cur) => cur ? cur[1].answer(acc, cur[0], InquiryP).join() : acc, x)\n    : x;\n// this is a bit complex, so here it goes:\n// Take all our IOUs (Questions), extract and resolve their Promises\n// then take those results apply to a tuple with the question name/description\nconst resolveQs = (x) => x.iou.join().length\n    ? x.iou.join().map((q) => q\n        .extract()()\n        .catch((err) => err)\n        .then((result) => Promise.resolve([q.name(), result])))\n    : [Promise.resolve()];\nconst InquiryP = (x) => ({\n    inquire: (f) => {\n        const extractName = (f) => f[symbols_1.$$questionSymbol]\n            ? f.name()\n            : f;\n        const fnName = typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = f[symbols_1.$$questionSymbol]\n            ? f.extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : x.questionset.find(fExtractFn);\n        const warnNotPassFail = (resp) => {\n            console.warn('inquire was passed a function that does not return Pass or Fail:', fnName);\n            console.warn('response was:', resp);\n            return InquiryP(x);\n        };\n        const inquireResponse = typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n        const syncronousResult = (response) => response[symbols_1.$$failSymbol] ||\n            response[symbols_1.$$passSymbol] ||\n            response[symbols_1.$$inquirySymbol]\n            ? response.answer(x, fnName, InquiryP)\n            : warnNotPassFail([inquireResponse, fnName]);\n        const inquireIOU = inquireResponse.then\n            ? QuestionOf([fnName, () => inquireResponse])\n            : false;\n        return inquireIOU\n            ? InquiryP({\n                subject: x.subject,\n                fail: x.fail,\n                pass: x.pass,\n                iou: x.iou.concat(IOU([inquireIOU])),\n                informant: x.informant,\n                questionset: x.questionset,\n                receipt: x.receipt\n            })\n            : syncronousResult(inquireResponse);\n    },\n    inquireMap: (f, i) => i.reduce((inq, ii) => {\n        const extractName = (f) => f[symbols_1.$$questionSymbol]\n            ? f.name()\n            : f;\n        const fnName = typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = f[symbols_1.$$questionSymbol]\n            ? f.extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : x.questionset.find(fExtractFn);\n        const warnNotPassFail = (resp) => {\n            console.warn('inquire was passed a function that does not return Pass or Fail:', fnName);\n            console.warn('response was:', resp);\n            return inq;\n        };\n        const inquireResponse = typeof inquire === 'function'\n            ? inquire(ii)(inq.join().subject.join())\n            : {};\n        const syncronousResult = (response) => response[symbols_1.$$failSymbol] ||\n            response[symbols_1.$$passSymbol] ||\n            response[symbols_1.$$inquirySymbol]\n            ? response.answer(inq.join(), fnName, InquiryP)\n            : warnNotPassFail(response);\n        return inquireResponse.then\n            ? InquiryP({\n                subject: inq.join().subject,\n                fail: inq.join().fail,\n                pass: inq.join().pass,\n                iou: inq.join().iou.concat(IOU([inquireResponse])),\n                informant: inq.join().informant,\n                questionset: inq.join().questionset,\n                receipt: inq.join().receipt\n            })\n            : syncronousResult(inquireResponse);\n    }, \n    // initial Inquiry will be what is in `x` now\n    InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    })),\n    inquireAll: () => x.questionset.chain((questions) => questions.reduce((inq, q) => inq.inquire(QuestionOf(q)), InquiryP(x))),\n    using: (a) => InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: x.informant,\n        questionset: a,\n        receipt: x.receipt\n    }),\n    // Informant: for spying/logging/observable\n    informant: (f) => InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: f,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    inspect: () => `InquiryP(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: () => InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(x.pass.join()),\n        pass: Pass(x.fail.join()),\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    // Mapping across both branches\n    unison: (f) => // apply a single map to both fail & pass (e.g. sort), iou untouched\n     InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(f(x.fail.join())),\n        pass: Pass(f(x.pass.join())),\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f) => InquiryPSubject(f(x)),\n    ap: (y) => y.map(x),\n    chain: (f) => f(x),\n    join: () => x,\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f) => x.fail.join().length ? InquiryP(f(x)) : InquiryP(x),\n    // execute the provided function if there are passes, else continue\n    milestone: (f) => x.pass.join().length ? InquiryP(f(x)) : InquiryP(x),\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i, n, _) => {\n        i.informant([n, InquiryP(x)]);\n        return InquiryP({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt\n        });\n    },\n    // Unwrapping methods: all return Promises, all complete outstanding IOUs\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: (f, g) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => ({\n            subject: y.subject,\n            iou: y.iou,\n            fail: f(y.fail),\n            pass: g(y.pass),\n            informant: y.informant,\n            questionset: y.questionset,\n            receipt: y.receipt\n        }));\n    }),\n    // If no fails, handoff aggregated passes to supplied function; if fails, return noop\n    cleared: (f) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? f(y.pass) : noop()))\n            .catch(err => console.error('err', err));\n    }),\n    // If fails, handoff aggregated fails to supplied function; if no fails, return noop\n    faulted: (f) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? noop() : f(y.fail)));\n    }),\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return noop\n    suffice: (f) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? noop() : f(y.pass)))\n            .catch(err => console.error('err', err));\n    }),\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return noop\n    scratch: (f) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? f(y.fail) : noop()));\n    }),\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: (f, g) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.join().length ? f(y.fail) : g(y.pass)));\n    }),\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fold: (f, g) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.join().length ? f(y.pass) : g(y.fail)));\n    }),\n    // return a Promise containing a merged fail/pass resultset array\n    zip: (f) => __awaiter(this, void 0, void 0, function* () {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then(y => f(y.fail.join().concat(y.pass.join())));\n    }),\n    // await all IOUs to resolve, then return a new Inquiry CONVERTS TO PROMISE!\n    await: (t = Infinity) => __awaiter(this, void 0, void 0, function* () {\n        // try: generator function. Each IOU = array in for loop as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\n        const timeLimit = new Promise((resolve, reject) => setTimeout(resolve, t, [\n            'timeout',\n            Fail('Promise(s) have timed out')\n        ]));\n        const awaitPromises = PromiseEvery(resolveQs(x));\n        return (Promise.race([timeLimit, awaitPromises])\n            // @ts-ignore\n            .then(buildInq(x))\n            .then((i) => (i[symbols_1.$$inquirySymbol] ? i.join() : i))\n            .then((y) => InquiryPOf(y)));\n    }),\n    [symbols_1.$$inquirySymbol]: true\n});\nconst exportInquiryP = {\n    subject: InquiryPSubject,\n    of: InquiryPOf\n};\nexports.InquiryP = exportInquiryP;\n//# sourceMappingURL=index.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__3__;","const $$JustSymbol = Symbol();\nconst $$NothingSymbol = Symbol();\n\nconst Just = x => ({\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    forkL: (_) => Nothing(),\n    forkR: (f) => f(x),\n    sequence: of => x.map(Maybe.of),\n    [$$JustSymbol]: true,\n    [$$NothingSymbol]: false\n});\n\nconst Nothing = _ => ({\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    forkL: (f) => f(),\n    forkR: () => Nothing(),\n    sequence: of => of(Nothing()),\n    [$$JustSymbol]: false,\n    [$$NothingSymbol]: true\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined || x[$$NothingSymbol] ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","import { Maybe } from 'simple-maybe';\nimport { Future, FutureInstance, done, FutureTypeRep } from 'fluture';\nimport { Pass, Fail, IOU, Questionset, Question, Receipt } from 'inquiry-monad';\n\nimport {\n    Monad,\n    InquiryMonad,\n    IOUMonad,\n    PassFailMonad,\n    PassMonad,\n    FailMonad,\n    InquiryValue,\n    ReceiptMonad,\n    ReceiptValue,\n    QuestionsetMonad,\n    QuestionMonad,\n    QuestionValue\n} from 'inquiry-monad/built/inquiry-monad';\n\nimport {\n    $$inquirySymbol,\n    $$questionsetSymbol,\n    $$questionSymbol,\n    $$passSymbol,\n    $$failSymbol,\n    $$iouSymbol,\n    $$receiptSymbol\n} from 'inquiry-monad/built/symbols';\n\nconst noop = (): void => {};\n\nconst buildInqF = (x: InquiryValue) => (vals: Array<any>) =>\n    vals.reduce(\n        (acc, cur) => cur[1].answer(acc.join(), '(async fn)', InquiryF),\n        InquiryF(x)\n    );\n\n// this is a bit complex, so here it goes:\n// Take all our IOUs (Questions), extract and resolve their Futures\n// then take those results apply to a tuple with the question name/description and result\nconst resolveQs = (x: InquiryValue): FutureInstance<any, any> =>\n    x.iou.join().length\n        ? Future((reject, resolve) => {\n              const results: Array<Array<PassMonad | FailMonad | string>> = [];\n              x.iou.join().map(\n                  (q: QuestionMonad): any => {\n                      q.extract()().fork(reject, (result: any) => {\n                          results.push([q.name(), result]);\n                          results.length === x.iou.join().length &&\n                              resolve(results);\n                      });\n                  }\n              );\n          })\n        : Future.of([]);\n\nconst InquiryFSubject = (x: any | InquiryMonad): InquiryMonad =>\n    x[$$inquirySymbol]\n        ? x\n        : InquiryF({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _,\n              questionset: Questionset.of([['', noop]]),\n              receipt: Receipt([])\n          });\n\nconst warnTypeErrorF = <T>(x: T) => {\n    console.warn(\n        'InquiryF.of requires properties: subject, fail, pass, iou, informant, questionset, receipt. Converting to InquiryF.subject().'\n    );\n    return InquiryFSubject(x);\n};\n\nconst InquiryFOf = (x: InquiryValue) =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x &&\n    'questionset' in x &&\n    'receipt' in x\n        ? InquiryF(x)\n        : warnTypeErrorF(x);\n\nconst InquiryF = (x: InquiryValue): InquiryMonad => ({\n    // Inquire: core method\n\n    inquire: (f: Function | string | QuestionMonad) => {\n        const extractName = (f: string | QuestionMonad) =>\n            (f as QuestionMonad)[$$questionSymbol]\n                ? (f as QuestionMonad).name()\n                : f;\n        const fnName =\n            typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = (f as any)[$$questionSymbol]\n            ? (f as QuestionMonad).extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n        const inquireResponse =\n            typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n\n        const warnNotPassFail = (resp: any): InquiryMonad => {\n            console.warn(\n                'inquire was passed a function that does not return Pass or Fail:',\n                fnName\n            );\n            return InquiryF(x);\n        };\n\n        const syncronousResult = (response: any): InquiryMonad =>\n            response[$$failSymbol] ||\n            response[$$passSymbol] ||\n            response[$$inquirySymbol]\n                ? response.answer(x, fnName, InquiryF)\n                : warnNotPassFail([inquireResponse, fnName]);\n\n        const inquireIOU =\n            inquireResponse instanceof Future\n                ? Question.of([fnName as string, () => inquireResponse])\n                : false;\n\n        return inquireIOU\n            ? InquiryF({\n                  subject: x.subject,\n                  fail: x.fail,\n                  pass: x.pass,\n                  iou: x.iou.concat(IOU([inquireIOU])),\n                  informant: x.informant,\n                  questionset: x.questionset,\n                  receipt: x.receipt\n              })\n            : syncronousResult(inquireResponse);\n    },\n\n    inquireMap: (\n        f: Function | string | QuestionMonad,\n        i: Array<any>\n    ): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const extractName = (f: string | QuestionMonad) =>\n                    (f as QuestionMonad)[$$questionSymbol]\n                        ? (f as QuestionMonad).name()\n                        : f;\n                const fnName =\n                    typeof f === 'function' ? f.name || 'anon' : extractName(f);\n                const fExtractFn = (f as any)[$$questionSymbol]\n                    ? (f as QuestionMonad).extract()\n                    : f;\n                const fIsFn = typeof fExtractFn === 'function';\n                const inquire = fIsFn\n                    ? fExtractFn\n                    : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n                const warnNotPassFail = (resp: any) => {\n                    console.warn(\n                        'inquire was passed a function that does not return Pass or Fail:',\n                        fnName\n                    );\n                    return inq;\n                };\n                const inquireResponse =\n                    typeof inquire === 'function'\n                        ? inquire(ii)(inq.join().subject.join())\n                        : {};\n\n                const syncronousResult = (response: any): InquiryMonad =>\n                    response[$$failSymbol] ||\n                    response[$$passSymbol] ||\n                    response[$$inquirySymbol]\n                        ? response.answer(inq.join(), fnName, InquiryF)\n                        : Pass(response).answer(x, fnName, InquiryF); // @todo this should be warNotPassFail\n\n                return inquireResponse instanceof Future\n                    ? InquiryF({\n                          subject: inq.join().subject,\n                          fail: inq.join().fail,\n                          pass: inq.join().pass,\n                          iou: inq.join().iou.concat(IOU([inquireResponse])),\n                          informant: inq.join().informant,\n                          questionset: inq.join().questionset,\n                          receipt: inq.join().receipt\n                      })\n                    : syncronousResult(inquireResponse);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            InquiryF({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant,\n                questionset: x.questionset,\n                receipt: x.receipt\n            })\n        ),\n\n    inquireAll: (): InquiryMonad =>\n        (x.questionset as QuestionsetMonad).chain(\n            (questions: Array<QuestionValue>): InquiryMonad =>\n                questions.reduce(\n                    (inq: InquiryMonad, q: QuestionValue): InquiryMonad =>\n                        inq.inquire(Question.of(q)),\n                    InquiryF(x)\n                )\n        ),\n\n    using: (a: QuestionsetMonad): InquiryMonad =>\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: x.informant,\n            questionset: a,\n            receipt: x.receipt\n        }),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        InquiryF({\n            // @todo accept array of functions instead, or have a plural version\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    inspect: (): string =>\n        `InquiryF(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: (): InquiryMonad =>\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort), iou untouched\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f: Function): InquiryMonad => InquiryFSubject(f(x)), // cast required for now\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): InquiryValue => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) => (x.fail.join().length ? f(x) : InquiryF(x)),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) => (x.pass.join().length ? f(x) : InquiryF(x)),\n\n    // internal method: execute informant, return new InquiryF() based on updated results\n    answer: (i: InquiryValue, n: string, _: Function): InquiryMonad => {\n        i.informant([n, InquiryF(x)]);\n        return InquiryF({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt\n        });\n    },\n\n    // Unwrapping methods: all complete outstanding IOUs\n\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    // this DOES NOT FORK\n    // callee MUST fork to retrieve supplied value\n    conclude: (f: Function, g: Function): FutureInstance<any, any> =>\n        Future((reject, resolve) =>\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map((i: any) => (i[$$inquirySymbol] ? i.join() : i))\n                .fork(reject, (y: InquiryValue) =>\n                    resolve({\n                        subject: y.subject,\n                        iou: y.iou,\n                        fail: f(y.fail),\n                        pass: g(y.pass),\n                        informant: y.informant,\n                        questionset: y.questionset,\n                        receipt: y.receipt\n                    })\n                )\n        ),\n\n    // If no fails, handoff aggregated passes to supplied function; if fails, return existing InquiryF\n    cleared: (f: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(\n                    console.error,\n                    (y: InquiryValue) =>\n                        y.fail.isEmpty() ? f(y.pass) : InquiryF(y)\n                )\n        ),\n\n    // If fails, handoff aggregated fails to supplied function; if no fails, return existing InquiryF\n    faulted: (f: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(\n                    console.error,\n                    (y: InquiryValue) =>\n                        y.fail.isEmpty() ? InquiryF(y) : f(y.fail)\n                )\n        ),\n\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return existing InquiryF\n    suffice: (f: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(\n                    console.error,\n                    (y: InquiryValue) =>\n                        y.pass.isEmpty() ? InquiryF(y) : f(y.pass)\n                )\n        ),\n\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return existing InquiryF\n    scratch: (f: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(\n                    console.error,\n                    (y: InquiryValue) =>\n                        y.pass.isEmpty() ? f(y.fail) : InquiryF(y)\n                )\n        ),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: (f: Function, g: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(\n                    console.error,\n                    (y: InquiryValue) =>\n                        y.fail.join().length ? f(y.fail) : g(y.pass)\n                )\n        ),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fold: (f: Function, g: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(\n                    console.error,\n                    (y: InquiryValue) =>\n                        y.pass.join().length ? f(y.pass) : g(y.fail)\n                )\n        ),\n\n    // return a Future containing a merged fail/pass resultset array\n    zip: (f: Function): FutureInstance<any, any> =>\n        Future.of(\n            resolveQs(x)\n                .map(buildInqF(x))\n                .map(\n                    <T>(i: T | InquiryMonad) =>\n                        $$inquirySymbol in (i as T)\n                            ? (i as InquiryMonad).join()\n                            : i\n                )\n                .fork(console.error, (y: InquiryValue) =>\n                    f(y.fail.join().concat(y.pass.join()))\n                )\n        ),\n\n    // resolves all IOUs, returns a Promise\n    // @ts-ignore @todo add .promise as optional part of an Inquiry\n    promise: (): Future<any, any> =>\n        resolveQs(x)\n            .map(buildInqF(x))\n            .promise(),\n\n    // @ts-ignore\n    [$$inquirySymbol]: true\n});\n\nconst exportInquiryF = {\n    subject: InquiryFSubject,\n    of: InquiryFOf\n};\n\nexport {\n    exportInquiryF as InquiryF,\n    Pass,\n    Fail,\n    IOU,\n    Future,\n    $$inquirySymbol,\n    Questionset,\n    Question,\n    Receipt\n};\n"],"sourceRoot":""}