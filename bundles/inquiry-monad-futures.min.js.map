{"version":3,"sources":["webpack://InquiryMonadFutures/webpack/universalModuleDefinition","webpack://InquiryMonadFutures/webpack/bootstrap","webpack://InquiryMonadFutures/./node_modules/simple-maybe/src/index.js","webpack://InquiryMonadFutures/./node_modules/inquiry-monad/built/index.js","webpack://InquiryMonadFutures/external \"Future\"","webpack://InquiryMonadFutures/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__2__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Just","x","isJust","isNothing","inspect","_","map","f","Maybe","of","ap","y","chain","join","fork","g","sequence","Nothing","undefined","__awaiter","this","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","apply","simple_maybe_1","IOU","concat","head","Array","isArray","length","tail","isEmpty","Boolean","isInquiry","isPass","isFail","isIOU","Pass","fold","answer","Inquiry","informant","subject","fail","iou","pass","Fail","InquirySubject","inquire","inquireResponse","swap","unison","breakpoint","milestone","conclude","cleared","faulted","zip","exportInquiry","InquiryPSubject","InquiryP","InquiryPOf","buildInq","vals","reduce","acc","cur","response","syncronousResult","all","catch","err","console","error","await","exportInquiryP","fluture_1","Future","inquiry_monad_1","buildInqF","InquiryF","InquiryFSubject","inquireMap","inq","ii","parallel","Infinity","suffice","scratch","promise","exportInquiryF","warn","warnTypeErrorF"],"mappings":"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","file":"inquiry-monad-futures.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Future\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InquiryMonadFutures\", [\"Future\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InquiryMonadFutures\"] = factory(require(\"Future\"));\n\telse\n\t\troot[\"InquiryMonadFutures\"] = factory(root[\"Future\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__2__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const Just = x => ({\n    isJust: true,\n    isNothing: false,\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    sequence: of => x.map(Maybe.of)\n});\n\nconst Nothing = _ => ({\n    isJust: false,\n    isNothing: true,\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    sequence: of => of(Nothing())\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst simple_maybe_1 = require(\"simple-maybe\");\nconst IOU = (x) => ({\n    map: (f) => IOU(f(x)),\n    chain: (f) => f(x),\n    ap: (y) => y.map(x),\n    inspect: () => `IOU(${x})`,\n    join: () => x,\n    concat: (o) => o.chain((r) => IOU(x.concat(r))),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isInquiry: false,\n    isPass: false,\n    isFail: false,\n    isIOU: true\n});\nexports.IOU = IOU;\nconst Pass = (x) => ({\n    map: (f) => Pass(f(x)),\n    chain: (f) => f(x),\n    fold: (f, _) => f(x),\n    fork: (_, f) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    join: () => x,\n    inspect: () => `Pass(${x})`,\n    concat: (o) => o.fold((r) => Pass(x.concat(r)), null),\n    ap: (y) => (y.isPass ? y.concat(Pass(x)) : Pass(x)),\n    answer: (i, n = '(anonymous)', c = Inquiry) => {\n        i.informant([n, Pass(x)]);\n        return c({\n            subject: i.subject,\n            fail: i.fail,\n            iou: i.iou,\n            pass: i.pass.concat(Pass(x)),\n            informant: i.informant\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isPass: true,\n    isFail: false,\n    isIOU: false,\n    isInquiry: false\n});\nexports.Pass = Pass;\nconst Fail = (x) => ({\n    map: (f) => Fail(f(x)),\n    chain: (f) => f(x),\n    fold: (_, f) => f(x),\n    fork: (f, _) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    join: () => x,\n    inspect: () => `Fail(${x})`,\n    concat: (o) => o.fork((r) => Fail(x.concat(r)), null),\n    ap: (y) => (y.isPass ? Fail(x) : y.concat(Fail(x))),\n    answer: (i, n = '(anonymous)', c = Inquiry) => {\n        i.informant([n, Fail(x)]);\n        return c({\n            subject: i.subject,\n            fail: i.fail.concat(Fail(x)),\n            pass: i.pass,\n            iou: i.iou,\n            informant: i.informant\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isPass: false,\n    isFail: true,\n    isIOU: false,\n    isInquiry: false\n});\nexports.Fail = Fail;\nconst InquirySubject = (x) => x.isInquiry\n    ? x\n    : Inquiry({\n        subject: simple_maybe_1.Maybe.of(x),\n        fail: Fail([]),\n        pass: Pass([]),\n        iou: IOU([]),\n        informant: (_) => _\n    });\nconst InquiryOf = (x) => Inquiry(x);\nconst Inquiry = (x) => ({\n    // Inquire: core method\n    inquire: (f) => {\n        const inquireResponse = f(x.subject.join());\n        return inquireResponse.isFail ||\n            inquireResponse.isPass ||\n            inquireResponse.isInquiry\n            ? inquireResponse.answer(x, f.name, Inquiry)\n            : Pass(inquireResponse);\n    },\n    // Informant: for spying/logging/observable\n    informant: (f) => Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: f\n    }),\n    inspect: () => `Inquiry(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n    // Flow control: swap pass/fail\n    swap: () => Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(x.pass.join()),\n        pass: Pass(x.fail.join()),\n        informant: x.informant\n    }),\n    // Mapping across both branches\n    unison: (f) => // apply a single map to both fail & pass (e.g. sort)\n     Inquiry({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(f(x.fail.join())),\n        pass: Pass(f(x.pass.join())),\n        informant: x.informant\n    }),\n    // standard Monad methods\n    map: (f) => InquirySubject(f(x)),\n    ap: (y) => y.map(x),\n    chain: (f) => f(x),\n    join: () => x,\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f) => (x.fail.join().length ? f(x) : Inquiry(x)),\n    // execute the provided function if there are passes, else continue\n    milestone: (f) => (x.pass.join().length ? f(x) : Inquiry(x)),\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i, n, _) => {\n        i.informant([n, Inquiry(x)]);\n        return Inquiry({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant\n        });\n    },\n    // Unwrap methods\n    // unwraps, mapping for both branches, full value returned\n    conclude: (f, g) => ({\n        subject: x.subject,\n        iou: x.iou,\n        fail: f(x.fail),\n        pass: g(x.pass),\n        informant: x.informant\n    }),\n    // If no fails, handoff aggregated passes to supplied function; if fails, return existing Inquiry\n    cleared: (f) => (x.fail.isEmpty() ? f(x.pass) : Inquiry(x)),\n    // If fails, handoff aggregated fails to supplied function; if no fails, return existing Inquiry\n    faulted: (f) => (x.fail.isEmpty() ? Inquiry(x) : f(x.fail)),\n    // unwrap left if fails, right if not\n    fork: (f, g) => x.fail.join().length ? f(x.fail) : g(x.pass),\n    // return a merged pass/fail\n    zip: (f) => f(x.fail.join().concat(x.pass.join())),\n    isInquiry: true\n});\nconst exportInquiry = {\n    subject: InquirySubject,\n    of: InquiryOf\n};\nexports.Inquiry = exportInquiry;\nconst InquiryPSubject = (x) => x.isInquiry\n    ? x\n    : InquiryP({\n        subject: simple_maybe_1.Maybe.of(x),\n        fail: Fail([]),\n        pass: Pass([]),\n        iou: IOU([]),\n        informant: (_) => _\n    });\nconst InquiryPOf = (x) => InquiryP(x);\nconst buildInq = (x) => (vals) => vals.reduce((acc, cur) => cur.answer(x, 'reduced', InquiryP), x);\nconst InquiryP = (x) => ({\n    // Inquire: core method\n    inquire: (f) => {\n        const inquireResponse = f(x.subject.join());\n        const syncronousResult = (response) => response.isFail || response.isPass || response.isInquiry\n            ? response.answer(x, f.name, InquiryP)\n            : Pass(response);\n        return inquireResponse.then\n            ? InquiryP({\n                subject: x.subject,\n                fail: x.fail,\n                pass: x.pass,\n                iou: x.iou.concat(IOU([inquireResponse])),\n                informant: x.informant\n            })\n            : syncronousResult(inquireResponse);\n    },\n    // Informant: for spying/logging/observable\n    informant: (f) => InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: x.fail,\n        pass: x.pass,\n        informant: f\n    }),\n    inspect: () => `InquiryP(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: () => InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(x.pass.join()),\n        pass: Pass(x.fail.join()),\n        informant: x.informant\n    }),\n    // Mapping across both branches\n    unison: (f) => // apply a single map to both fail & pass (e.g. sort), iou untouched\n     InquiryP({\n        subject: x.subject,\n        iou: x.iou,\n        fail: Fail(f(x.fail.join())),\n        pass: Pass(f(x.pass.join())),\n        informant: x.informant\n    }),\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f) => InquiryPSubject(f(x)),\n    ap: (y) => y.map(x),\n    chain: (f) => f(x),\n    join: () => x,\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f) => (x.fail.join().length ? f(x) : InquiryP(x)),\n    // execute the provided function if there are passes, else continue\n    milestone: (f) => (x.pass.join().length ? f(x) : InquiryP(x)),\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i, n, _) => {\n        i.informant([n, InquiryP(x)]);\n        return InquiryP({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant\n        });\n    },\n    // Unwrapping methods: all return Promises, all complete outstanding IOUs\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: (f, g) => __awaiter(this, void 0, void 0, function* () {\n        return Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => ({\n            subject: y.subject,\n            iou: y.iou,\n            fail: f(y.fail),\n            pass: g(y.pass),\n            informant: y.informant\n        }));\n    }),\n    // If no fails, handoff aggregated passes to supplied function; if fails, return existing InquiryP\n    cleared: (f) => __awaiter(this, void 0, void 0, function* () {\n        return Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? f(y.pass) : InquiryP(y)))\n            .catch(err => console.error('err', err));\n    }),\n    // If fails, handoff aggregated fails to supplied function; if no fails, return existing InquiryP\n    faulted: (f) => __awaiter(this, void 0, void 0, function* () {\n        return Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? InquiryP(y) : f(y.fail)));\n    }),\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: (f, g) => __awaiter(this, void 0, void 0, function* () {\n        return Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.fail.join().length ? f(y.fail) : g(y.pass)));\n    }),\n    // return a Promise containing a merged fail/pass resultset array\n    zip: (f) => __awaiter(this, void 0, void 0, function* () {\n        return Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => f(y.fail.join().concat(y.pass.join())));\n    }),\n    // await all IOUs to resolve, then return a new Inquiry\n    await: () => __awaiter(this, void 0, void 0, function* () {\n        return Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => InquiryPOf(y));\n    }),\n    isInquiry: true\n});\nconst exportInquiryP = {\n    subject: InquiryPSubject,\n    of: InquiryPOf\n};\nexports.InquiryP = exportInquiryP;\n//# sourceMappingURL=index.js.map","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","import { Maybe } from 'simple-maybe';\nimport { Future } from 'fluture';\nimport { Pass, Fail, IOU } from 'inquiry-monad';\n\nconst buildInqF = <T>(x: T) => (vals: Array<any>) =>\n    vals.reduce((acc, cur) => cur.answer(acc, '(async fn)', InquiryF), x);\n\nconst InquiryFSubject = <T>(x: T | InquiryMonad) =>\n    (x as any).isInquiry\n        ? x\n        : InquiryF({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _\n          });\n\nconst warnTypeErrorF = <T>(x: T) => {\n    console.warn(\n        'InquiryF.of requires properties: subject, fail, pass, iou, informant. Converting to InquiryF.subject().'\n    );\n    return InquiryFSubject(x);\n};\n\nconst InquiryFOf = (x: Inquiry) =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x\n        ? InquiryF(x)\n        : warnTypeErrorF(x);\n\nconst InquiryF = (x: Inquiry): InquiryMonad => ({\n    // Inquire: core method\n    inquire: (f: Function) => {\n        const inquireResponse = f(x.subject.join());\n        const syncronousResult = (response: any) =>\n            response.isFail || response.isPass || response.isInquiry\n                ? response.answer(x, f.name, InquiryF)\n                : Pass(response);\n\n        return inquireResponse instanceof Future\n            ? InquiryF({\n                  subject: x.subject,\n                  fail: x.fail,\n                  pass: x.pass,\n                  iou: x.iou.concat(IOU([inquireResponse])),\n                  informant: x.informant\n              })\n            : syncronousResult(inquireResponse);\n    },\n\n    inquireMap: (f: Function, i: Array<any>): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const inquireResponse = f(ii)(inq.join().subject.join());\n\n                const syncronousResult = (response: any) =>\n                    response.isFail || response.isPass || response.isInquiry\n                        ? response.answer(inq.join(), f.name, InquiryF)\n                        : Pass(response);\n\n                return inquireResponse.then\n                    ? InquiryF({\n                          subject: inq.join().subject,\n                          fail: inq.join().fail,\n                          pass: inq.join().pass,\n                          iou: inq.join().iou.concat(IOU([inquireResponse])),\n                          informant: inq.join().informant\n                      })\n                    : syncronousResult(inquireResponse);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            InquiryF({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant\n            })\n        ),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        InquiryF({\n            // @todo accept array of functions instead, or have a plural version\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f\n        }),\n\n    inspect: (): string =>\n        `InquiryF(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: (): InquiryMonad =>\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort), iou untouched\n        InquiryF({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant\n        }),\n\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f: Function): Inquiry => InquiryFSubject(f(x)), // cast required for now\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): Inquiry => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) => (x.fail.join().length ? f(x) : InquiryF(x)),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) => (x.pass.join().length ? f(x) : InquiryF(x)),\n\n    // internal method: execute informant, return new InquiryF() based on updated results\n    answer: (i: Inquiry, n: string, _: Function): InquiryMonad => {\n        i.informant([n, InquiryF(x)]);\n        return InquiryF({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant\n        });\n    },\n\n    // Unwrapping methods: all return Futures, all complete outstanding IOUs\n\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: (f: Function, g: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map((i: any) => (i.isInquiry ? i.join() : i))\n            .fork(console.error, (y: Inquiry) => ({\n                subject: y.subject,\n                iou: y.iou,\n                fail: f(y.fail),\n                pass: g(y.pass),\n                informant: y.informant\n            })),\n\n    // If no fails, handoff aggregated passes to supplied function; if fails, return existing InquiryF\n    cleared: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    'isInquiry' in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: Inquiry) => (y.fail.isEmpty() ? f(y.pass) : InquiryF(y))\n            ),\n\n    // If fails, handoff aggregated fails to supplied function; if no fails, return existing InquiryF\n    faulted: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    'isInquiry' in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: Inquiry) => (y.fail.isEmpty() ? InquiryF(y) : f(y.fail))\n            ),\n\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return existing InquiryF\n    suffice: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    'isInquiry' in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: Inquiry) => (y.pass.isEmpty() ? InquiryF(y) : f(y.pass))\n            ),\n\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return existing InquiryF\n    scratch: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    'isInquiry' in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: Inquiry) => (y.pass.isEmpty() ? f(y.fail) : InquiryF(y))\n            ),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: (f: Function, g: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    'isInquiry' in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(\n                console.error,\n                (y: Inquiry) => (y.fail.join().length ? f(y.fail) : g(y.pass))\n            ),\n\n    // return a Future containing a merged fail/pass resultset array\n    zip: (f: Function): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .map(\n                <T>(i: T | InquiryMonad) =>\n                    'isInquiry' in (i as T) ? (i as InquiryMonad).join() : i\n            )\n            .fork(console.error, (y: Inquiry) =>\n                f(y.fail.join().concat(y.pass.join()))\n            ),\n\n    // resolves all IOUs, returns a Promise\n    promise: (): Future<any, any> =>\n        // @ts-ignore\n        Future.parallel(Infinity, x.iou.join())\n            .map(buildInqF(x))\n            .promise(),\n\n    isInquiry: true\n});\n\nconst exportInquiryF = {\n    subject: InquiryFSubject,\n    of: InquiryFOf\n};\n\nexport { exportInquiryF as InquiryF, Pass, Fail, IOU, Future };\n"],"sourceRoot":""}